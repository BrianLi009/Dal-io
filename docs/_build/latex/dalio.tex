%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{User Modules:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Dal.io}
\date{Jun 29, 2020}
\release{0.1.1}
\author{Renato Zimmermann}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{dalio.external package}
\label{\detokenize{dalio.external:dalio-external-package}}\label{\detokenize{dalio.external::doc}}

\section{Submodules}
\label{\detokenize{dalio.external:submodules}}

\section{dalio.external.external}
\label{\detokenize{dalio.external:module-dalio.external.external}}\label{\detokenize{dalio.external:dalio-external-external}}\index{dalio.external.external (module)@\spxentry{dalio.external.external}\spxextra{module}}
Define abstract External class

External instances manage connections between your environment and an
external source. Class instacnes will often be redundant with existing
connection handlers, but at least subclasses will allow for more integrated
connection handling and collection, so that you can have a single connection
object for each external connection.
\index{External (class in dalio.external.external)@\spxentry{External}\spxextra{class in dalio.external.external}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.external.External}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.external.}}\sphinxbfcode{\sphinxupquote{External}}}{\emph{config=None}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.base.node.\_Node}}

Represents external data input or output

External instances have one external input and one internal output or one
internal input and one external output.
\index{\_connection (dalio.external.external.External attribute)@\spxentry{\_connection}\spxextra{dalio.external.external.External attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.external.External._connection}}\pysigline{\sphinxbfcode{\sphinxupquote{\_connection}}}
connection with outside source of data

\end{fulllineitems}

\index{\_config (dalio.external.external.External attribute)@\spxentry{\_config}\spxextra{dalio.external.external.External attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.external.External._config}}\pysigline{\sphinxbfcode{\sphinxupquote{\_config}}}
authentication settings for outside sources
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{authenticate() (dalio.external.external.External method)@\spxentry{authenticate()}\spxextra{dalio.external.external.External method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.external.External.authenticate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{authenticate}}}{}{}
Establish a connection with the source.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if authenication is successful or if it is already existent
False if the authentication fails.

\end{description}\end{quote}

\end{fulllineitems}

\index{check() (dalio.external.external.External method)@\spxentry{check()}\spxextra{dalio.external.external.External method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.external.External.check}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check}}}{}{}
Check if connection is ready to request data
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Whether data is ready to be requested

\end{description}\end{quote}

\end{fulllineitems}

\index{request() (dalio.external.external.External method)@\spxentry{request()}\spxextra{dalio.external.external.External method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.external.External.request}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{request}}}{\emph{**kwargs}}{}
Request data to or from an external source

\end{fulllineitems}

\index{update\_config() (dalio.external.external.External method)@\spxentry{update\_config()}\spxextra{dalio.external.external.External method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.external.External.update_config}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update\_config}}}{\emph{new\_conf}}{}
Update configuration dict with new data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{new\_conf}} \textendash{} dictionary with new configurations or file containing
configuration settings translatable to a dictionary

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if config is a non\sphinxhyphen{}existent file or not a dict.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{dalio.external.file}
\label{\detokenize{dalio.external:module-dalio.external.file}}\label{\detokenize{dalio.external:dalio-external-file}}\index{dalio.external.file (module)@\spxentry{dalio.external.file}\spxextra{module}}
Define File IO classes

Files are external sources of data that can be processed in several ways as
raw data used in a graph.
\index{FileWriter (class in dalio.external.file)@\spxentry{FileWriter}\spxextra{class in dalio.external.file}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.file.FileWriter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.file.}}\sphinxbfcode{\sphinxupquote{FileWriter}}}{\emph{out\_file=\textless{}\_io.TextIOWrapper name=\textquotesingle{}\textless{}stdout\textgreater{}\textquotesingle{} mode=\textquotesingle{}w\textquotesingle{} encoding=\textquotesingle{}UTF\sphinxhyphen{}8\textquotesingle{}\textgreater{}}}{}
Bases: {\hyperref[\detokenize{dalio.external:dalio.external.external.External}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.external.external.External}}}}}

File string writer
\index{\_connection (dalio.external.file.FileWriter attribute)@\spxentry{\_connection}\spxextra{dalio.external.file.FileWriter attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.file.FileWriter._connection}}\pysigline{\sphinxbfcode{\sphinxupquote{\_connection}}}
any file instance that can be written on

\end{fulllineitems}

\index{check() (dalio.external.file.FileWriter method)@\spxentry{check()}\spxextra{dalio.external.file.FileWriter method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.file.FileWriter.check}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check}}}{}{}
Check if there is an open file as the connection

\end{fulllineitems}

\index{request() (dalio.external.file.FileWriter method)@\spxentry{request()}\spxextra{dalio.external.file.FileWriter method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.file.FileWriter.request}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{request}}}{\emph{**kwargs}}{}
Write a request string onto a file

\end{fulllineitems}

\index{set\_connection() (dalio.external.file.FileWriter method)@\spxentry{set\_connection()}\spxextra{dalio.external.file.FileWriter method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.file.FileWriter.set_connection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_connection}}}{\emph{new\_connection}}{}
Set current connection

Set connection to opened file or open a new file given the path to
one.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{new\_connection}} \textendash{} open file instance or path to an existing file.

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{IOError}} \textendash{} if specified path does not exist.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if specified “new\_connection” argument is of an
    invalid type

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PandasInFile (class in dalio.external.file)@\spxentry{PandasInFile}\spxextra{class in dalio.external.file}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.file.PandasInFile}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.file.}}\sphinxbfcode{\sphinxupquote{PandasInFile}}}{\emph{in\_file}}{}
Bases: {\hyperref[\detokenize{dalio.external:dalio.external.external.External}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.external.external.External}}}}}

Get data from a file using the pandas package
\index{\_connection (dalio.external.file.PandasInFile attribute)@\spxentry{\_connection}\spxextra{dalio.external.file.PandasInFile attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.file.PandasInFile._connection}}\pysigline{\sphinxbfcode{\sphinxupquote{\_connection}}}
path to a file that can be read by some pandas
function.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{check() (dalio.external.file.PandasInFile method)@\spxentry{check()}\spxextra{dalio.external.file.PandasInFile method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.file.PandasInFile.check}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check}}}{}{}
Check if connection is ready to request data
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Whether data is ready to be requested

\end{description}\end{quote}

\end{fulllineitems}

\index{request() (dalio.external.file.PandasInFile method)@\spxentry{request()}\spxextra{dalio.external.file.PandasInFile method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.file.PandasInFile.request}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{request}}}{\emph{**kwargs}}{}
Get data input from a file according to its extension
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} arguments to the inport function.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{dalio.external.image}
\label{\detokenize{dalio.external:module-dalio.external.image}}\label{\detokenize{dalio.external:dalio-external-image}}\index{dalio.external.image (module)@\spxentry{dalio.external.image}\spxextra{module}}
Define classes for image pieces

Images, be it a plot, picture or video are considered external outputs as the
figure itself is not contained in the python session, and must be shown in a
screen or server.
\index{Figure (class in dalio.external.image)@\spxentry{Figure}\spxextra{class in dalio.external.image}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.Figure}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.image.}}\sphinxbfcode{\sphinxupquote{Figure}}}
Bases: {\hyperref[\detokenize{dalio.external:dalio.external.external.External}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.external.external.External}}}}}

Base Figure class

These serve to implement the basic logic of a figure, and are not limited
to any specific python package. Python packages should be standardazied
in these classes to take in these broad commands.
\index{\_connection (dalio.external.image.Figure attribute)@\spxentry{\_connection}\spxextra{dalio.external.image.Figure attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.Figure._connection}}\pysigline{\sphinxbfcode{\sphinxupquote{\_connection}}}
figure object dealt with by this class

\end{fulllineitems}

\index{check() (dalio.external.image.Figure method)@\spxentry{check()}\spxextra{dalio.external.image.Figure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.Figure.check}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check}}}{}{}
Check if there is a figure to return

\end{fulllineitems}

\index{plot() (dalio.external.image.Figure method)@\spxentry{plot()}\spxextra{dalio.external.image.Figure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.Figure.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{\emph{data}, \emph{coords=None}, \emph{kind=None}, \emph{**graph\_opts}}{}
Plots data on the figure.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data to be used in the plot.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coords}} \textendash{} coordinates or location of a target graph

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kind}} \textendash{} kind of plot to be plotted. None by default.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**graph\_opts}} \textendash{} optional graphing options

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{request() (dalio.external.image.Figure method)@\spxentry{request()}\spxextra{dalio.external.image.Figure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.Figure.request}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{request}}}{\emph{**kwargs}}{}
Processes a request based on the figure.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} additional request options.

\end{description}\end{quote}

\end{fulllineitems}

\index{reset() (dalio.external.image.Figure method)@\spxentry{reset()}\spxextra{dalio.external.image.Figure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.Figure.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Resets figure to default, empty state

\end{fulllineitems}


\end{fulllineitems}

\index{PyPfOptGraph (class in dalio.external.image)@\spxentry{PyPfOptGraph}\spxextra{class in dalio.external.image}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PyPfOptGraph}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.image.}}\sphinxbfcode{\sphinxupquote{PyPfOptGraph}}}
Bases: {\hyperref[\detokenize{dalio.external:dalio.external.image.PyPlotGraph}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.external.image.PyPlotGraph}}}}}

Graphs data from the PyPfOpt package
\index{plot() (dalio.external.image.PyPfOptGraph method)@\spxentry{plot()}\spxextra{dalio.external.image.PyPfOptGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PyPfOptGraph.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{\emph{data}, \emph{coords=None}, \emph{kind=None}, \emph{**kwargs}}{}
Graph data from pypfopt
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} plottable data from pypfopt package

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if data is not of a plottable class from pypfopt

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PyPlotGraph (class in dalio.external.image)@\spxentry{PyPlotGraph}\spxextra{class in dalio.external.image}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PyPlotGraph}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.image.}}\sphinxbfcode{\sphinxupquote{PyPlotGraph}}}
Bases: {\hyperref[\detokenize{dalio.external:dalio.external.image.Figure}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.external.image.Figure}}}}}

Figure from the matplotlib.pyplot package.
\index{\_connection (dalio.external.image.PyPlotGraph attribute)@\spxentry{\_connection}\spxextra{dalio.external.image.PyPlotGraph attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PyPlotGraph._connection}}\pysigline{\sphinxbfcode{\sphinxupquote{\_connection}}}
graph figure
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
matplotlib.pyplot.Figure

\end{description}\end{quote}

\end{fulllineitems}

\index{\_axes (dalio.external.image.PyPlotGraph attribute)@\spxentry{\_axes}\spxextra{dalio.external.image.PyPlotGraph attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PyPlotGraph._axes}}\pysigline{\sphinxbfcode{\sphinxupquote{\_axes}}}
figure axis
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
matplotlib.axes.\_subplots.AxesSubplot

\end{description}\end{quote}

\end{fulllineitems}

\index{plot() (dalio.external.image.PyPlotGraph method)@\spxentry{plot()}\spxextra{dalio.external.image.PyPlotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PyPlotGraph.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{\emph{data}, \emph{coords=None}, \emph{kind=None}, \emph{**graph\_opts}}{}
Plot x onto the x\sphinxhyphen{}axis and y onto the y\sphinxhyphen{}axis, if applicable.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{matrix}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{array like}}) \textendash{} either data to be plotted on the x
axis or a tuple of x and y data to be plotted or the x and y
axis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kind}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} kind of graph.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**graph\_opts}} \textendash{} plt plotting arguments for this kind of graph.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{request() (dalio.external.image.PyPlotGraph method)@\spxentry{request()}\spxextra{dalio.external.image.PyPlotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PyPlotGraph.request}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{request}}}{\emph{**kwargs}}{}
Processed request for data.

This adds the SHOW request to the base class implementation

\end{fulllineitems}

\index{reset() (dalio.external.image.PyPlotGraph method)@\spxentry{reset()}\spxextra{dalio.external.image.PyPlotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PyPlotGraph.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Set connection and axes to a single figure and axis

\end{fulllineitems}


\end{fulllineitems}

\index{PySubplotGraph (class in dalio.external.image)@\spxentry{PySubplotGraph}\spxextra{class in dalio.external.image}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PySubplotGraph}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.image.}}\sphinxbfcode{\sphinxupquote{PySubplotGraph}}}{\emph{rows=1}, \emph{cols=1}}{}
Bases: {\hyperref[\detokenize{dalio.external:dalio.external.image.Figure}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.external.image.Figure}}}}}

A matplotlib.pyplot.Figure containing multiple subplots.

This has a set number of axes, rows and columns which can be accessed
individually to have data plotted on. These will often be used inside of
applications that require more than one subplot all contained in the
same instance.
\index{\_rows (dalio.external.image.PySubplotGraph attribute)@\spxentry{\_rows}\spxextra{dalio.external.image.PySubplotGraph attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PySubplotGraph._rows}}\pysigline{\sphinxbfcode{\sphinxupquote{\_rows}}}
number of rows in the subplot
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{\_cols (dalio.external.image.PySubplotGraph attribute)@\spxentry{\_cols}\spxextra{dalio.external.image.PySubplotGraph attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PySubplotGraph._cols}}\pysigline{\sphinxbfcode{\sphinxupquote{\_cols}}}
number of columns in the subplot
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{\_axes (dalio.external.image.PySubplotGraph attribute)@\spxentry{\_axes}\spxextra{dalio.external.image.PySubplotGraph attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PySubplotGraph._axes}}\pysigline{\sphinxbfcode{\sphinxupquote{\_axes}}}
array of the figure’s axes
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_axis() (dalio.external.image.PySubplotGraph method)@\spxentry{get\_axis()}\spxextra{dalio.external.image.PySubplotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PySubplotGraph.get_axis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_axis}}}{\emph{coords}}{}
Gets a specific axis from the \_axis attribute at given
coordinates

\end{fulllineitems}

\index{make\_manager() (dalio.external.image.PySubplotGraph method)@\spxentry{make\_manager()}\spxextra{dalio.external.image.PySubplotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PySubplotGraph.make_manager}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{make\_manager}}}{\emph{coords}}{}
Create a SubPlotManager to manage this instance’s subplots

\end{fulllineitems}

\index{plot() (dalio.external.image.PySubplotGraph method)@\spxentry{plot()}\spxextra{dalio.external.image.PySubplotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PySubplotGraph.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{\emph{data}, \emph{coords=None}, \emph{kind=None}, \emph{**graph\_opts}}{}
Plot on a specified subplot axis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{coords}} (\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}) \textendash{} tuple of subplot coordinates to plot data

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if coordinates are out of range.

\end{description}\end{quote}

\end{fulllineitems}

\index{reset() (dalio.external.image.PySubplotGraph method)@\spxentry{reset()}\spxextra{dalio.external.image.PySubplotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PySubplotGraph.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Resets figure and all axes

\end{fulllineitems}


\end{fulllineitems}

\index{SubplotManager (class in dalio.external.image)@\spxentry{SubplotManager}\spxextra{class in dalio.external.image}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.SubplotManager}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.image.}}\sphinxbfcode{\sphinxupquote{SubplotManager}}}{\emph{subplot}, \emph{coords}}{}
Bases: {\hyperref[\detokenize{dalio.external:dalio.external.image.PyPlotGraph}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.external.image.PyPlotGraph}}}}}

A manager object for treating a subplot axis like a single plot.

Applications will often take in single plots and have their functionality
catered to such. Subplots, while useful, will often be used for specific
applications. A subplot manager allows you to create multiple subplots
and pass each one individually onto applications that take a single
subplot axis and still have access to the underlying figure.
\index{reset() (dalio.external.image.SubplotManager method)@\spxentry{reset()}\spxextra{dalio.external.image.SubplotManager method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.SubplotManager.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Set connection and axes to a single figure and axis

\end{fulllineitems}


\end{fulllineitems}



\section{dalio.external.web}
\label{\detokenize{dalio.external:module-dalio.external.web}}\label{\detokenize{dalio.external:dalio-external-web}}\index{dalio.external.web (module)@\spxentry{dalio.external.web}\spxextra{module}}
Define web external request classes
\index{QuandlAPI (class in dalio.external.web)@\spxentry{QuandlAPI}\spxextra{class in dalio.external.web}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.web.QuandlAPI}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.web.}}\sphinxbfcode{\sphinxupquote{QuandlAPI}}}{\emph{config=None}}{}
Bases: {\hyperref[\detokenize{dalio.external:dalio.external.external.External}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.external.external.External}}}}}

Set up the Quandl API and request table data from quandl.
\index{\_quandl\_conf (dalio.external.web.QuandlAPI attribute)@\spxentry{\_quandl\_conf}\spxextra{dalio.external.web.QuandlAPI attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.web.QuandlAPI._quandl_conf}}\pysigline{\sphinxbfcode{\sphinxupquote{\_quandl\_conf}}}
Quandl API config object

\end{fulllineitems}

\index{authenticate() (dalio.external.web.QuandlAPI method)@\spxentry{authenticate()}\spxextra{dalio.external.web.QuandlAPI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.web.QuandlAPI.authenticate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{authenticate}}}{}{}
Set the api key if it is available in the config dictionary
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if key was successfully set, False otherwise

\end{description}\end{quote}

\end{fulllineitems}

\index{check() (dalio.external.web.QuandlAPI method)@\spxentry{check()}\spxextra{dalio.external.web.QuandlAPI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.web.QuandlAPI.check}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check}}}{}{}
Check if the api key is set

\end{fulllineitems}

\index{request() (dalio.external.web.QuandlAPI method)@\spxentry{request()}\spxextra{dalio.external.web.QuandlAPI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.web.QuandlAPI.request}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{request}}}{\emph{**kwargs}}{}
Request table data from quandl
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} keyword arguments for quandl request.
query: table to get data from.
filter: dictionary of filters for data. Depends on table.
columns: columns to select.

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{IOError}} \textendash{} if api key is not set.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if filters kwarg is not a dict.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{YahooDR (class in dalio.external.web)@\spxentry{YahooDR}\spxextra{class in dalio.external.web}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.web.YahooDR}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.web.}}\sphinxbfcode{\sphinxupquote{YahooDR}}}{\emph{config=None}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.external.web.\_PDR}}

Represents financial data from Yahoo! Finance
\index{request() (dalio.external.web.YahooDR method)@\spxentry{request()}\spxextra{dalio.external.web.YahooDR method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.web.YahooDR.request}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{request}}}{\emph{**kwargs}}{}
Get data from specified tickers

\end{fulllineitems}


\end{fulllineitems}



\chapter{dalio.translator package}
\label{\detokenize{dalio.translator:dalio-translator-package}}\label{\detokenize{dalio.translator::doc}}

\section{Submodules}
\label{\detokenize{dalio.translator:submodules}}

\section{dalio.translator.file}
\label{\detokenize{dalio.translator:module-dalio.translator.file}}\label{\detokenize{dalio.translator:dalio-translator-file}}\index{dalio.translator.file (module)@\spxentry{dalio.translator.file}\spxextra{module}}
Translator for common file imports

These will often be very specific to the file being imported, but should
strive to still be as flexible as possible. These will often hold the format
translated to constant and try being adaptable with the data to fit it. So
it is more importat to begin with the output and then adapt to the input, not
the other way.
\index{StockStreamFileTranslator (class in dalio.translator.file)@\spxentry{StockStreamFileTranslator}\spxextra{class in dalio.translator.file}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.file.StockStreamFileTranslator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.translator.file.}}\sphinxbfcode{\sphinxupquote{StockStreamFileTranslator}}}{\emph{date\_col=None}, \emph{att\_name=None}}{}
Bases: {\hyperref[\detokenize{dalio.translator:dalio.translator.translator.Translator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.translator.translator.Translator}}}}}

Create a DataFrame conforming to the STOCK\_STREAM validator preset.
\begin{description}
\item[{The STOCK\_STREAM preset includes:}] \leavevmode\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{)}%
\item {} 
having a time series index,

\item {} 
being a dataframe,

\item {} \begin{description}
\item[{having a multiindex column with levels named ATTRIBUTE and TICKER.}] \leavevmode
Such that an imported excel file will have column names renamed
that or assume a single column name row is of ticker names.

\end{description}

\end{enumerate}

\end{description}
\index{date\_col (dalio.translator.file.StockStreamFileTranslator attribute)@\spxentry{date\_col}\spxextra{dalio.translator.file.StockStreamFileTranslator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.file.StockStreamFileTranslator.date_col}}\pysigline{\sphinxbfcode{\sphinxupquote{date\_col}}}
column name to get date data from.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{att\_name (dalio.translator.file.StockStreamFileTranslator attribute)@\spxentry{att\_name}\spxextra{dalio.translator.file.StockStreamFileTranslator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.file.StockStreamFileTranslator.att_name}}\pysigline{\sphinxbfcode{\sphinxupquote{att\_name}}}
name of the attribute column if imported dataframe
column has only one level.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.translator.file.StockStreamFileTranslator method)@\spxentry{copy()}\spxextra{dalio.translator.file.StockStreamFileTranslator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.file.StockStreamFileTranslator.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (dalio.translator.file.StockStreamFileTranslator method)@\spxentry{run()}\spxextra{dalio.translator.file.StockStreamFileTranslator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.file.StockStreamFileTranslator.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Request pandas data from file and format it into a dataframe that
complies with the STOCK\_STREAM validator preset
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} 
Optional request arguments
TICKER: single ticker or iterable of tickers to filter for
\begin{quote}

in data.
\end{quote}


\end{description}\end{quote}

\end{fulllineitems}

\index{translations (dalio.translator.file.StockStreamFileTranslator attribute)@\spxentry{translations}\spxextra{dalio.translator.file.StockStreamFileTranslator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.file.StockStreamFileTranslator.translations}}\pysigline{\sphinxbfcode{\sphinxupquote{translations}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}


\end{fulllineitems}



\section{dalio.translator.pdr}
\label{\detokenize{dalio.translator:module-dalio.translator.pdr}}\label{\detokenize{dalio.translator:dalio-translator-pdr}}\index{dalio.translator.pdr (module)@\spxentry{dalio.translator.pdr}\spxextra{module}}
Define translators for data from the pandas\_datareader package
\index{YahooStockTranslator (class in dalio.translator.pdr)@\spxentry{YahooStockTranslator}\spxextra{class in dalio.translator.pdr}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.pdr.YahooStockTranslator}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.translator.pdr.}}\sphinxbfcode{\sphinxupquote{YahooStockTranslator}}}
Bases: {\hyperref[\detokenize{dalio.translator:dalio.translator.translator.Translator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.translator.translator.Translator}}}}}

Translate stock data gathered from Yahoo! Finance
\index{run() (dalio.translator.pdr.YahooStockTranslator method)@\spxentry{run()}\spxextra{dalio.translator.pdr.YahooStockTranslator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.pdr.YahooStockTranslator.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Request data subset and translate columns
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} optional run arguments.
TICKER: ticker to get data from.

\end{description}\end{quote}

\end{fulllineitems}

\index{translations (dalio.translator.pdr.YahooStockTranslator attribute)@\spxentry{translations}\spxextra{dalio.translator.pdr.YahooStockTranslator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.pdr.YahooStockTranslator.translations}}\pysigline{\sphinxbfcode{\sphinxupquote{translations}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}


\end{fulllineitems}



\section{dalio.translator.quandl}
\label{\detokenize{dalio.translator:module-dalio.translator.quandl}}\label{\detokenize{dalio.translator:dalio-translator-quandl}}\index{dalio.translator.quandl (module)@\spxentry{dalio.translator.quandl}\spxextra{module}}
Define Translator instances for data imported from quandl.

These should be designed with both input and output in mind as quandl inputs
can, for a good extent, known from the table and query, both of which are
known from the time of request. This means that these translators should be
designed to be more specific to the query instead of being flexible.
\index{QuandlSharadarSF1Translator (class in dalio.translator.quandl)@\spxentry{QuandlSharadarSF1Translator}\spxextra{class in dalio.translator.quandl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.quandl.QuandlSharadarSF1Translator}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.translator.quandl.}}\sphinxbfcode{\sphinxupquote{QuandlSharadarSF1Translator}}}
Bases: {\hyperref[\detokenize{dalio.translator:dalio.translator.translator.Translator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.translator.translator.Translator}}}}}

Import and translate data from the SHARADAR/SF1 table
\index{run() (dalio.translator.quandl.QuandlSharadarSF1Translator method)@\spxentry{run()}\spxextra{dalio.translator.quandl.QuandlSharadarSF1Translator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.quandl.QuandlSharadarSF1Translator.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get input from quandl’s SHARADAR/SF1 table, and format
according to the STOCK\_STREAM validator preset.

\end{fulllineitems}

\index{translations (dalio.translator.quandl.QuandlSharadarSF1Translator attribute)@\spxentry{translations}\spxextra{dalio.translator.quandl.QuandlSharadarSF1Translator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.quandl.QuandlSharadarSF1Translator.translations}}\pysigline{\sphinxbfcode{\sphinxupquote{translations}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}


\end{fulllineitems}

\index{QuandlTickerInfoTranslator (class in dalio.translator.quandl)@\spxentry{QuandlTickerInfoTranslator}\spxextra{class in dalio.translator.quandl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.quandl.QuandlTickerInfoTranslator}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.translator.quandl.}}\sphinxbfcode{\sphinxupquote{QuandlTickerInfoTranslator}}}
Bases: {\hyperref[\detokenize{dalio.translator:dalio.translator.translator.Translator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.translator.translator.Translator}}}}}

Import and translate data from the SHARADAR/TICKERS table
\index{run() (dalio.translator.quandl.QuandlTickerInfoTranslator method)@\spxentry{run()}\spxextra{dalio.translator.quandl.QuandlTickerInfoTranslator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.quandl.QuandlTickerInfoTranslator.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get input from quandl’s SHARADAR/TICKER table, and format
according to the STOCK\_INFO validator preset.

\end{fulllineitems}

\index{translations (dalio.translator.quandl.QuandlTickerInfoTranslator attribute)@\spxentry{translations}\spxextra{dalio.translator.quandl.QuandlTickerInfoTranslator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.quandl.QuandlTickerInfoTranslator.translations}}\pysigline{\sphinxbfcode{\sphinxupquote{translations}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}


\end{fulllineitems}



\section{dalio.translator.translator}
\label{\detokenize{dalio.translator:module-dalio.translator.translator}}\label{\detokenize{dalio.translator:dalio-translator-translator}}\index{dalio.translator.translator (module)@\spxentry{dalio.translator.translator}\spxextra{module}}
Define Translator class

Translators are the root of all data that feeds your graph. Objects of this
take in data from some external source then “translates” it into a format that
can be used universaly by other elements in this package. Please consult the
translation manual to make this as usabel as possible and make extensive use
of the base tools to build translations.
\index{Translator (class in dalio.translator.translator)@\spxentry{Translator}\spxextra{class in dalio.translator.translator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.translator.Translator}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.translator.translator.}}\sphinxbfcode{\sphinxupquote{Translator}}}
Bases: \sphinxcode{\sphinxupquote{dalio.base.transformer.\_Transformer}}
\index{\_source (dalio.translator.translator.Translator attribute)@\spxentry{\_source}\spxextra{dalio.translator.translator.Translator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.translator.Translator._source}}\pysigline{\sphinxbfcode{\sphinxupquote{\_source}}}
Connection used to retrieve raw data from outide source.

\end{fulllineitems}

\index{translations (dalio.translator.translator.Translator attribute)@\spxentry{translations}\spxextra{dalio.translator.translator.Translator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.translator.Translator.translations}}\pysigline{\sphinxbfcode{\sphinxupquote{translations}}}
dictionary of translations from vocabulaary used in the
data source to base constants. These should be created from
initialization and kept unmodified. This is to ensure data coming
through a translator is though of before usage to ensure
integrity.

\end{fulllineitems}

\index{set\_input() (dalio.translator.translator.Translator method)@\spxentry{set\_input()}\spxextra{dalio.translator.translator.Translator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.translator.Translator.set_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_input}}}{\emph{new\_input}}{}
See base class

\end{fulllineitems}

\index{translate\_item() (dalio.translator.translator.Translator method)@\spxentry{translate\_item()}\spxextra{dalio.translator.translator.Translator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.translator.Translator.translate_item}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{translate\_item}}}{\emph{item}}{}
Translate all items of an iterable
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{item}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{any}}) \textendash{} item or iterator of items to translate.

\item[{Returns}] \leavevmode
A list with the translated names.

\end{description}\end{quote}

\end{fulllineitems}

\index{translations (dalio.translator.translator.Translator attribute)@\spxentry{translations}\spxextra{dalio.translator.translator.Translator attribute}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{translations}}\sphinxbfcode{\sphinxupquote{: Dict{[}str, str{]}}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{update\_translations() (dalio.translator.translator.Translator method)@\spxentry{update\_translations()}\spxextra{dalio.translator.translator.Translator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.translator.Translator.update_translations}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update\_translations}}}{\emph{new\_translations}}{}
Update translations dictionary with new dictrionary

\end{fulllineitems}

\index{with\_input() (dalio.translator.translator.Translator method)@\spxentry{with\_input()}\spxextra{dalio.translator.translator.Translator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.translator.Translator.with_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{with\_input}}}{\emph{new\_input}}{}
See base class

\end{fulllineitems}


\end{fulllineitems}



\chapter{dalio.pipe package}
\label{\detokenize{dalio.pipe:dalio-pipe-package}}\label{\detokenize{dalio.pipe::doc}}

\section{Submodules}
\label{\detokenize{dalio.pipe:submodules}}

\section{dalio.pipe.builders}
\label{\detokenize{dalio.pipe:module-dalio.pipe.builders}}\label{\detokenize{dalio.pipe:dalio-pipe-builders}}\index{dalio.pipe.builders (module)@\spxentry{dalio.pipe.builders}\spxextra{module}}
Builder Pipes
\index{CovShrink (class in dalio.pipe.builders)@\spxentry{CovShrink}\spxextra{class in dalio.pipe.builders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.CovShrink}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.builders.}}\sphinxbfcode{\sphinxupquote{CovShrink}}}{\emph{frequency=252}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}, \sphinxcode{\sphinxupquote{dalio.base.builder.\_Builder}}

Perform Covariance Shrinkage on data

Builder with a single piece: shirnkage. Shrinkage defines what kind of
shrinkage to apply on a resultant covariance matrix. If none is set,
covariance will not be shrunk.
\index{frequency (dalio.pipe.builders.CovShrink attribute)@\spxentry{frequency}\spxextra{dalio.pipe.builders.CovShrink attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.CovShrink.frequency}}\pysigline{\sphinxbfcode{\sphinxupquote{frequency}}}
data time period frequency
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{build\_model() (dalio.pipe.builders.CovShrink method)@\spxentry{build\_model()}\spxextra{dalio.pipe.builders.CovShrink method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.CovShrink.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}}{}
Builds Covariance Srhinkage object and returns selected shrinkage
strategy
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Function fitted on the data.

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_name() (dalio.pipe.builders.CovShrink method)@\spxentry{check\_name()}\spxextra{dalio.pipe.builders.CovShrink method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.CovShrink.check_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_name}}}{\emph{param}, \emph{name}}{}
Check if name and parameter combination is valid.

This will always be called upon setting a new piece to ensure this
piece is present dictionary and that the name is valid. Subclasses
will often override this method to implement the name checks in
accordance to their specific name parameter combination options.
Notice that checks cannot be done on arguments before running the
\_Builder. This also can be called from outside of a \_Builder instance
to check for the validity of settings.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{piece}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the key in the piece dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name option to be set to the piece.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{frequency (dalio.pipe.builders.CovShrink attribute)@\spxentry{frequency}\spxextra{dalio.pipe.builders.CovShrink attribute}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{frequency}}\sphinxbfcode{\sphinxupquote{: int}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{transform() (dalio.pipe.builders.CovShrink method)@\spxentry{transform()}\spxextra{dalio.pipe.builders.CovShrink method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.CovShrink.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Build model using data get results.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A covariance matrix

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ExpectedReturns (class in dalio.pipe.builders)@\spxentry{ExpectedReturns}\spxextra{class in dalio.pipe.builders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ExpectedReturns}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.builders.}}\sphinxbfcode{\sphinxupquote{ExpectedReturns}}}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}, \sphinxcode{\sphinxupquote{dalio.base.builder.\_Builder}}

Get stock’s time series expected returns.

Builder with a single piece: return\_model. return\_model is what model to
get the expected returns from.
\index{build\_model() (dalio.pipe.builders.ExpectedReturns method)@\spxentry{build\_model()}\spxextra{dalio.pipe.builders.ExpectedReturns method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ExpectedReturns.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}}{}
Assemble pieces into a model given some data

The data will opten be optional, but several builder models will
require it to be fitted on initialization. Which further shows why
builders are necessary for context\sphinxhyphen{}agnostic graphs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data that might be used to build the model.

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_name() (dalio.pipe.builders.ExpectedReturns method)@\spxentry{check\_name()}\spxextra{dalio.pipe.builders.ExpectedReturns method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ExpectedReturns.check_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_name}}}{\emph{param}, \emph{name}}{}
Check if name and parameter combination is valid.

This will always be called upon setting a new piece to ensure this
piece is present dictionary and that the name is valid. Subclasses
will often override this method to implement the name checks in
accordance to their specific name parameter combination options.
Notice that checks cannot be done on arguments before running the
\_Builder. This also can be called from outside of a \_Builder instance
to check for the validity of settings.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{piece}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the key in the piece dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name option to be set to the piece.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.builders.ExpectedReturns method)@\spxentry{transform()}\spxextra{dalio.pipe.builders.ExpectedReturns method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ExpectedReturns.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Builds model using data and gets expected returns from it

\end{fulllineitems}


\end{fulllineitems}

\index{ExpectedShortfall (class in dalio.pipe.builders)@\spxentry{ExpectedShortfall}\spxextra{class in dalio.pipe.builders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ExpectedShortfall}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.builders.}}\sphinxbfcode{\sphinxupquote{ExpectedShortfall}}}{\emph{quantiles=None}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.builders.ValueAtRisk}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.builders.ValueAtRisk}}}}}

Get expected shortfal for given quantiles

See base class for more in depth explanation.
\index{transform() (dalio.pipe.builders.ExpectedShortfall method)@\spxentry{transform()}\spxextra{dalio.pipe.builders.ExpectedShortfall method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ExpectedShortfall.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Get the value at risk given by an arch model and calculate the
expected shortfall at given quantiles.

\end{fulllineitems}


\end{fulllineitems}

\index{LinearModel (class in dalio.pipe.builders)@\spxentry{LinearModel}\spxextra{class in dalio.pipe.builders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.LinearModel}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.builders.}}\sphinxbfcode{\sphinxupquote{LinearModel}}}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}, \sphinxcode{\sphinxupquote{dalio.base.builder.\_Builder}}

Create a linear model from input data.

This builder is made up of a single piece: strategy. This piece sets
which linear model should be used to fit the data.
\index{build\_model() (dalio.pipe.builders.LinearModel method)@\spxentry{build\_model()}\spxextra{dalio.pipe.builders.LinearModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.LinearModel.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}}{}
Build model by returning the chosen model and initialization
parameters
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Unfitted linear model

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.builders.LinearModel method)@\spxentry{copy()}\spxextra{dalio.pipe.builders.LinearModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.LinearModel.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.builders.LinearModel method)@\spxentry{transform()}\spxextra{dalio.pipe.builders.LinearModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.LinearModel.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Set up fitting parameters and fit built model.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Fitted linear model

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{MakeARCH (class in dalio.pipe.builders)@\spxentry{MakeARCH}\spxextra{class in dalio.pipe.builders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.MakeARCH}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.builders.}}\sphinxbfcode{\sphinxupquote{MakeARCH}}}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}, \sphinxcode{\sphinxupquote{dalio.base.builder.\_Builder}}

Build arch model and make it based on input data.

This class allows for the creation of arch models by configuring three
pieces: the mean, volatility and distribution. These are set after
initialization through the \_Builder interface.
\index{\_piece (dalio.pipe.builders.MakeARCH attribute)@\spxentry{\_piece}\spxextra{dalio.pipe.builders.MakeARCH attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.MakeARCH._piece}}\pysigline{\sphinxbfcode{\sphinxupquote{\_piece}}}
see \_Builder class.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{assimilate() (dalio.pipe.builders.MakeARCH method)@\spxentry{assimilate()}\spxextra{dalio.pipe.builders.MakeARCH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.MakeARCH.assimilate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{assimilate}}}{\emph{model}}{}
Assimilate core pieces of an existent ARCH Model.

Assimilation means setting this model’s’ pieces in accordance to an
existing model’s pieces. Assimilation is shallow, so only the main
pieces are assimilated, not their parameters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{model}} (\sphinxstyleliteralemphasis{\sphinxupquote{ARCHModel}}) \textendash{} Existing ARCH Model.

\end{description}\end{quote}

\end{fulllineitems}

\index{build\_model() (dalio.pipe.builders.MakeARCH method)@\spxentry{build\_model()}\spxextra{dalio.pipe.builders.MakeARCH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.MakeARCH.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}}{}
Build ARCH Model using data, set pieces and their arguments
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A built arch model from the arch package.

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.builders.MakeARCH method)@\spxentry{copy()}\spxextra{dalio.pipe.builders.MakeARCH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.MakeARCH.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.builders.MakeARCH method)@\spxentry{transform()}\spxextra{dalio.pipe.builders.MakeARCH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.MakeARCH.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Build model with sourced data

\end{fulllineitems}


\end{fulllineitems}

\index{StockComps (class in dalio.pipe.builders)@\spxentry{StockComps}\spxextra{class in dalio.pipe.builders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.StockComps}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.builders.}}\sphinxbfcode{\sphinxupquote{StockComps}}}{\emph{strategy=\textquotesingle{}sic\_code\textquotesingle{}}, \emph{max\_ticks=6}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Get a list of a ticker’s comparable stocks

This can utilize any strategy of getting stock comparative companies and
return up to a certain ammount of comps.
\index{\_strategy (dalio.pipe.builders.StockComps attribute)@\spxentry{\_strategy}\spxextra{dalio.pipe.builders.StockComps attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.StockComps._strategy}}\pysigline{\sphinxbfcode{\sphinxupquote{\_strategy}}}
comparisson strategy name or function.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str, callable

\end{description}\end{quote}

\end{fulllineitems}

\index{max\_ticks (dalio.pipe.builders.StockComps attribute)@\spxentry{max\_ticks}\spxextra{dalio.pipe.builders.StockComps attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.StockComps.max_ticks}}\pysigline{\sphinxbfcode{\sphinxupquote{max\_ticks}}}
maximum number of tickers to return.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.builders.StockComps method)@\spxentry{copy()}\spxextra{dalio.pipe.builders.StockComps method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.StockComps.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{max\_ticks (dalio.pipe.builders.StockComps attribute)@\spxentry{max\_ticks}\spxextra{dalio.pipe.builders.StockComps attribute}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{max\_ticks}}\sphinxbfcode{\sphinxupquote{: int}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{run() (dalio.pipe.builders.StockComps method)@\spxentry{run()}\spxextra{dalio.pipe.builders.StockComps method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.StockComps.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Gets ticker argument and passes an empty ticker request to
transform.

Empty ticker requests are supposed to return all tickers available in
a source, so this allows the compariisson to be made in all stocks
from a certain source.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if ticker is more than a single symbol.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.builders.StockComps method)@\spxentry{transform()}\spxextra{dalio.pipe.builders.StockComps method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.StockComps.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Get comps according to the set strategy

\end{fulllineitems}


\end{fulllineitems}

\index{ValueAtRisk (class in dalio.pipe.builders)@\spxentry{ValueAtRisk}\spxextra{class in dalio.pipe.builders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ValueAtRisk}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.builders.}}\sphinxbfcode{\sphinxupquote{ValueAtRisk}}}{\emph{quantiles=None}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Get the value at risk for data based on an ARHC Model

This takes in an ARCH Model maker, not data, which might be unintuitive,
yet necessary, as this allows users to modify the ARCH model generating
these values separately. A useful strategy that allows for this
is using a pipeline with an arch model as its first input and a
ValueAtRisk instance as its second layer. This allows us to treat the
PipeLine as a data input with VaR output and still have control over the
ARCH Model pieces (given you left a local variable for it behind.)
\index{\_quantiles (dalio.pipe.builders.ValueAtRisk attribute)@\spxentry{\_quantiles}\spxextra{dalio.pipe.builders.ValueAtRisk attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ValueAtRisk._quantiles}}\pysigline{\sphinxbfcode{\sphinxupquote{\_quantiles}}}
list of quantiles to check the value at risk for.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.builders.ValueAtRisk method)@\spxentry{copy()}\spxextra{dalio.pipe.builders.ValueAtRisk method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ValueAtRisk.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.builders.ValueAtRisk method)@\spxentry{transform()}\spxextra{dalio.pipe.builders.ValueAtRisk method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ValueAtRisk.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Get values at risk at each quantile and each results maximum
exedence from the mean.

The maximum exedence columns tells which quantile the loss is placed
on. The word “maximum” might be misleading as it is compared to the
minimum quantile, however, this definition is accurate as the column
essentially answers the question: “what quantile furthest away from
the mean does the data exeed?”

Thank you for the creators of the arch package for the beautiful
visualizations and ideas!
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if ARCH model does not have returns. This is often
    the case for unfitted models. Ensure your graph is complete.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if ARCH model has unsuported distribution parameter.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{dalio.pipe.col\_generation}
\label{\detokenize{dalio.pipe:module-dalio.pipe.col_generation}}\label{\detokenize{dalio.pipe:dalio-pipe-col-generation}}\index{dalio.pipe.col\_generation (module)@\spxentry{dalio.pipe.col\_generation}\spxextra{module}}
Implement transformations that generates new colums from exising ones
\index{Change (class in dalio.pipe.col\_generation)@\spxentry{Change}\spxextra{class in dalio.pipe.col\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Change}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.}}\sphinxbfcode{\sphinxupquote{Change}}}{\emph{strategy=\textquotesingle{}pct\_change\textquotesingle{}}, \emph{cols=None}, \emph{new\_cols=None}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Perform item\sphinxhyphen{}by\sphinxhyphen{}item change

This has two main forms, percentage change and absolute change
(difference).
\index{\_strategy (dalio.pipe.col\_generation.Change attribute)@\spxentry{\_strategy}\spxextra{dalio.pipe.col\_generation.Change attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Change._strategy}}\pysigline{\sphinxbfcode{\sphinxupquote{\_strategy}}}
change strategy.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str, callable

\end{description}\end{quote}

\end{fulllineitems}

\index{\_new\_cols (dalio.pipe.col\_generation.Change attribute)@\spxentry{\_new\_cols}\spxextra{dalio.pipe.col\_generation.Change attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Change._new_cols}}\pysigline{\sphinxbfcode{\sphinxupquote{\_new\_cols}}}
either list of new columns or suffix.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list, str

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.col\_generation.Change method)@\spxentry{copy()}\spxextra{dalio.pipe.col\_generation.Change method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Change.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.col\_generation.Change method)@\spxentry{transform()}\spxextra{dalio.pipe.col\_generation.Change method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Change.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Applies change transformation to sourced data

\end{fulllineitems}


\end{fulllineitems}

\index{Index (class in dalio.pipe.col\_generation)@\spxentry{Index}\spxextra{class in dalio.pipe.col\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Index}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.}}\sphinxbfcode{\sphinxupquote{Index}}}{\emph{index\_at}, \emph{cols=None}, \emph{groupby=None}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Index data at a specified value
\index{index\_at (dalio.pipe.col\_generation.Index attribute)@\spxentry{index\_at}\spxextra{dalio.pipe.col\_generation.Index attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Index.index_at}}\pysigline{\sphinxbfcode{\sphinxupquote{index\_at}}}
value to index data at
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int, float

\end{description}\end{quote}

\end{fulllineitems}

\index{\_cols (dalio.pipe.col\_generation.Index attribute)@\spxentry{\_cols}\spxextra{dalio.pipe.col\_generation.Index attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Index._cols}}\pysigline{\sphinxbfcode{\sphinxupquote{\_cols}}}
columns to index
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{\_groupby (dalio.pipe.col\_generation.Index attribute)@\spxentry{\_groupby}\spxextra{dalio.pipe.col\_generation.Index attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Index._groupby}}\pysigline{\sphinxbfcode{\sphinxupquote{\_groupby}}}
columns to group data by
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.col\_generation.Index method)@\spxentry{copy()}\spxextra{dalio.pipe.col\_generation.Index method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Index.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{index\_at (dalio.pipe.col\_generation.Index attribute)@\spxentry{index\_at}\spxextra{dalio.pipe.col\_generation.Index attribute}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{index\_at}}\sphinxbfcode{\sphinxupquote{: int}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{transform() (dalio.pipe.col\_generation.Index method)@\spxentry{transform()}\spxextra{dalio.pipe.col\_generation.Index method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Index.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Perform indexing

\end{fulllineitems}


\end{fulllineitems}

\index{Period (class in dalio.pipe.col\_generation)@\spxentry{Period}\spxextra{class in dalio.pipe.col\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Period}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.}}\sphinxbfcode{\sphinxupquote{Period}}}{\emph{period=None}, \emph{agg\_func=\textless{}function mean\textgreater{}}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Resample input time series data to a different period
\index{agg\_func (dalio.pipe.col\_generation.Period attribute)@\spxentry{agg\_func}\spxextra{dalio.pipe.col\_generation.Period attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Period.agg_func}}\pysigline{\sphinxbfcode{\sphinxupquote{agg\_func}}}
function to aggregate data to one period.
Default set to np.mean.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
callable

\end{description}\end{quote}

\end{fulllineitems}

\index{\_period (dalio.pipe.col\_generation.Period attribute)@\spxentry{\_period}\spxextra{dalio.pipe.col\_generation.Period attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Period._period}}\pysigline{\sphinxbfcode{\sphinxupquote{\_period}}}
period to resample data to. Can be either daily,
monthly, quarterly or yearly.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{agg\_func (dalio.pipe.col\_generation.Period attribute)@\spxentry{agg\_func}\spxextra{dalio.pipe.col\_generation.Period attribute}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{agg\_func}}\sphinxbfcode{\sphinxupquote{: Callable{[}{[}Iterable{]}, Any{]}}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{copy() (dalio.pipe.col\_generation.Period method)@\spxentry{copy()}\spxextra{dalio.pipe.col\_generation.Period method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Period.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.col\_generation.Period method)@\spxentry{transform()}\spxextra{dalio.pipe.col\_generation.Period method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Period.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply data resampling

\end{fulllineitems}


\end{fulllineitems}

\index{Rolling (class in dalio.pipe.col\_generation)@\spxentry{Rolling}\spxextra{class in dalio.pipe.col\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Rolling}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.}}\sphinxbfcode{\sphinxupquote{Rolling}}}{\emph{window=2}, \emph{rolling\_func=\textless{}function Rolling.\textless{}lambda\textgreater{}\textgreater{}}, \emph{cols=None}, \emph{new\_cols=None}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Apply rolling function to columns
\index{\_rolling\_func (dalio.pipe.col\_generation.Rolling attribute)@\spxentry{\_rolling\_func}\spxextra{dalio.pipe.col\_generation.Rolling attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Rolling._rolling_func}}\pysigline{\sphinxbfcode{\sphinxupquote{\_rolling\_func}}}
function to be performed on a window.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
callable

\end{description}\end{quote}

\end{fulllineitems}

\index{\_window (dalio.pipe.col\_generation.Rolling attribute)@\spxentry{\_window}\spxextra{dalio.pipe.col\_generation.Rolling attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Rolling._window}}\pysigline{\sphinxbfcode{\sphinxupquote{\_window}}}
size of the rolling window
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.col\_generation.Rolling method)@\spxentry{copy()}\spxextra{dalio.pipe.col\_generation.Rolling method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Rolling.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.col\_generation.Rolling method)@\spxentry{transform()}\spxextra{dalio.pipe.col\_generation.Rolling method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Rolling.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply rolling transformation to sourced data

\end{fulllineitems}


\end{fulllineitems}

\index{StockReturns (class in dalio.pipe.col\_generation)@\spxentry{StockReturns}\spxextra{class in dalio.pipe.col\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.StockReturns}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.}}\sphinxbfcode{\sphinxupquote{StockReturns}}}{\emph{cols=None}, \emph{new\_cols=False}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.col_generation.Change}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.Change}}}}}

Perform percent change and minor aesthetic changes to data
\index{transform() (dalio.pipe.col\_generation.StockReturns method)@\spxentry{transform()}\spxextra{dalio.pipe.col\_generation.StockReturns method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.StockReturns.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Same as base class but with relevant presets and multiplying by
100 for aesthetic purposes

\end{fulllineitems}


\end{fulllineitems}



\section{dalio.pipe.custom}
\label{\detokenize{dalio.pipe:module-dalio.pipe.custom}}\label{\detokenize{dalio.pipe:dalio-pipe-custom}}\index{dalio.pipe.custom (module)@\spxentry{dalio.pipe.custom}\spxextra{module}}
Custom transformation
\index{Custom (class in dalio.pipe.custom)@\spxentry{Custom}\spxextra{class in dalio.pipe.custom}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.custom.Custom}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.custom.}}\sphinxbfcode{\sphinxupquote{Custom}}}{\emph{t\_func}, \emph{*args}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Custom transformation for simple operations.

These are very useful for simple operations or for testing, as no
additional class definitions or understanding of the documentation is
requred.
\index{t\_func (dalio.pipe.custom.Custom attribute)@\spxentry{t\_func}\spxextra{dalio.pipe.custom.Custom attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.custom.Custom.t_func}}\pysigline{\sphinxbfcode{\sphinxupquote{t\_func}}}
function to transform data with preset arguments.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
callable

\end{description}\end{quote}

\end{fulllineitems}

\index{\_args (dalio.pipe.custom.Custom attribute)@\spxentry{\_args}\spxextra{dalio.pipe.custom.Custom attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.custom.Custom._args}}\pysigline{\sphinxbfcode{\sphinxupquote{\_args}}}
arguments to be passed onto the function at execution time.

\end{fulllineitems}

\index{\_kwargs (dalio.pipe.custom.Custom attribute)@\spxentry{\_kwargs}\spxextra{dalio.pipe.custom.Custom attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.custom.Custom._kwargs}}\pysigline{\sphinxbfcode{\sphinxupquote{\_kwargs}}}
arguments to be passed onto the function at execution
time.

\end{fulllineitems}

\index{copy() (dalio.pipe.custom.Custom method)@\spxentry{copy()}\spxextra{dalio.pipe.custom.Custom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.custom.Custom.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{t\_func (dalio.pipe.custom.Custom attribute)@\spxentry{t\_func}\spxextra{dalio.pipe.custom.Custom attribute}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{t\_func}}\sphinxbfcode{\sphinxupquote{: callable}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{transform() (dalio.pipe.custom.Custom method)@\spxentry{transform()}\spxextra{dalio.pipe.custom.Custom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.custom.Custom.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply a transformation to data returned from source.

This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data returned by source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{dalio.pipe.forecast}
\label{\detokenize{dalio.pipe:module-dalio.pipe.forecast}}\label{\detokenize{dalio.pipe:dalio-pipe-forecast}}\index{dalio.pipe.forecast (module)@\spxentry{dalio.pipe.forecast}\spxextra{module}}
Transformations makes forecasts based on data
\index{Forecast (class in dalio.pipe.forecast)@\spxentry{Forecast}\spxextra{class in dalio.pipe.forecast}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.forecast.Forecast}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.forecast.}}\sphinxbfcode{\sphinxupquote{Forecast}}}{\emph{horizon=10}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Generalized forecasting class.

This should be used mostly for subclassing or very generic forecasting
interfaces.
\index{horizon (dalio.pipe.forecast.Forecast attribute)@\spxentry{horizon}\spxextra{dalio.pipe.forecast.Forecast attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.forecast.Forecast.horizon}}\pysigline{\sphinxbfcode{\sphinxupquote{horizon}}}
how many steps ahead to forecast
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{horizon (dalio.pipe.forecast.Forecast attribute)@\spxentry{horizon}\spxextra{dalio.pipe.forecast.Forecast attribute}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{horizon}}\sphinxbfcode{\sphinxupquote{: int}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{transform() (dalio.pipe.forecast.Forecast method)@\spxentry{transform()}\spxextra{dalio.pipe.forecast.Forecast method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.forecast.Forecast.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Return forecast of data

\end{fulllineitems}


\end{fulllineitems}

\index{GARCHForecast (class in dalio.pipe.forecast)@\spxentry{GARCHForecast}\spxextra{class in dalio.pipe.forecast}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.forecast.GARCHForecast}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.forecast.}}\sphinxbfcode{\sphinxupquote{GARCHForecast}}}{\emph{start=None}, \emph{horizon=1}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.forecast.Forecast}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.forecast.Forecast}}}}}

Forecast data based on a fitted GARCH model
\index{\_start (dalio.pipe.forecast.GARCHForecast attribute)@\spxentry{\_start}\spxextra{dalio.pipe.forecast.GARCHForecast attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.forecast.GARCHForecast._start}}\pysigline{\sphinxbfcode{\sphinxupquote{\_start}}}
forecast start time and date.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
pd.Timestamp

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.forecast.GARCHForecast method)@\spxentry{transform()}\spxextra{dalio.pipe.forecast.GARCHForecast method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.forecast.GARCHForecast.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Make a mean, variance and residual variance forecast.

Forecast will be made for the specified horizon starting at the
specified time. This means that will only get data for the steps
starting at the specified start date and the steps after it.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A DataFrame with the columns MEAN, VARIANCE and RESIDUAL\_VARIANCE
for the time horizon after the start date.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{dalio.pipe.pipe}
\label{\detokenize{dalio.pipe:module-dalio.pipe.pipe}}\label{\detokenize{dalio.pipe:dalio-pipe-pipe}}\index{dalio.pipe.pipe (module)@\spxentry{dalio.pipe.pipe}\spxextra{module}}
Defines the Pipe and PipeLine classes

Pipes are perhaps the most common classes in graphs and represent any
transformation with one input and one output. Pipes\textasciigrave{} main functionality
revolves around the .transform() method, which actually applies a
transformation to data retrieved from a source. Pipes must also implement
propper data checks by adding descriptions to their source.
\index{Pipe (class in dalio.pipe.pipe)@\spxentry{Pipe}\spxextra{class in dalio.pipe.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.pipe.}}\sphinxbfcode{\sphinxupquote{Pipe}}}
Bases: \sphinxcode{\sphinxupquote{dalio.base.transformer.\_Transformer}}

Pipes represend data modifications with one internal input and one
internal output.
\index{\_source (dalio.pipe.pipe.Pipe attribute)@\spxentry{\_source}\spxextra{dalio.pipe.pipe.Pipe attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe._source}}\pysigline{\sphinxbfcode{\sphinxupquote{\_source}}}
input data definition
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\_DataDef

\end{description}\end{quote}

\end{fulllineitems}

\index{pipeline() (dalio.pipe.pipe.Pipe method)@\spxentry{pipeline()}\spxextra{dalio.pipe.pipe.Pipe method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe.pipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pipeline}}}{\emph{*args}}{}
Returns a PipeLine instance with self as the input source and any
other Pipe instances as part of its pipeline.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} any additional Pipe to be added to the pipeline, in that
order.

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (dalio.pipe.pipe.Pipe method)@\spxentry{run()}\spxextra{dalio.pipe.pipe.Pipe method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get data from source, transform it, and return it

This will often be left alone unless there are specific keyword
arguments or checks done in addition to the actual transformation.
Keep in mind this is rare, as keyword arguments are often required
by Translators, and checks are performed by DataDefs.

\end{fulllineitems}

\index{set\_input() (dalio.pipe.pipe.Pipe method)@\spxentry{set\_input()}\spxextra{dalio.pipe.pipe.Pipe method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe.set_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_input}}}{\emph{new\_input}}{}
Set the input data source in place.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{new\_input}} (\sphinxstyleliteralemphasis{\sphinxupquote{\_Transformer}}) \textendash{} new transformer to be set as input to
source connection.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if new\_input is not an instance of \_Transformer.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.pipe.Pipe method)@\spxentry{transform()}\spxextra{dalio.pipe.pipe.Pipe method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply a transformation to data returned from source.

This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data returned by source.

\end{description}\end{quote}

\end{fulllineitems}

\index{with\_input() (dalio.pipe.pipe.Pipe method)@\spxentry{with\_input()}\spxextra{dalio.pipe.pipe.Pipe method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe.with_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{with\_input}}}{\emph{new\_input}}{}
Return copy of this transformer with the new data source.

\end{fulllineitems}


\end{fulllineitems}

\index{PipeLine (class in dalio.pipe.pipe)@\spxentry{PipeLine}\spxextra{class in dalio.pipe.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.PipeLine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.pipe.}}\sphinxbfcode{\sphinxupquote{PipeLine}}}{\emph{first}, \emph{*args}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Collection of Pipe transformations.

PipeLine instances represent multiple Pipe transformations being
performed consecutively. Pipelines essentially execute multiple
transformations one after the other, and thus do not check for data
integrity in between them; so keep in mind that order matters and only
the first data definition will be enforced.
\index{pipeline (dalio.pipe.pipe.PipeLine attribute)@\spxentry{pipeline}\spxextra{dalio.pipe.pipe.PipeLine attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.PipeLine.pipeline}}\pysigline{\sphinxbfcode{\sphinxupquote{pipeline}}}
list of Pipe instaces this pipeline is composed of
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.pipe.PipeLine method)@\spxentry{copy()}\spxextra{dalio.pipe.pipe.PipeLine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.PipeLine.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Make a copy of this Pipeline

\end{fulllineitems}

\index{extend() (dalio.pipe.pipe.PipeLine method)@\spxentry{extend()}\spxextra{dalio.pipe.pipe.PipeLine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.PipeLine.extend}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extend}}}{\emph{*args}}{}
Extend existing pipeline with one or more Pipe instances

\end{fulllineitems}

\index{transform() (dalio.pipe.pipe.PipeLine method)@\spxentry{transform()}\spxextra{dalio.pipe.pipe.PipeLine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.PipeLine.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Pass data sourced from first pipe through every Pipe\textasciigrave{}s
.transform() method in order.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data sourced and checked from first source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{dalio.pipe.selection}
\label{\detokenize{dalio.pipe:module-dalio.pipe.selection}}\label{\detokenize{dalio.pipe:dalio-pipe-selection}}\index{dalio.pipe.selection (module)@\spxentry{dalio.pipe.selection}\spxextra{module}}
Defines various ways of getting a subset of data based on some condition
\index{ColSelect (class in dalio.pipe.selection)@\spxentry{ColSelect}\spxextra{class in dalio.pipe.selection}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.selection.ColSelect}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.selection.}}\sphinxbfcode{\sphinxupquote{ColSelect}}}{\emph{cols=None}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Select columns.
\index{\_cols (dalio.pipe.selection.ColSelect attribute)@\spxentry{\_cols}\spxextra{dalio.pipe.selection.ColSelect attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.selection.ColSelect._cols}}\pysigline{\sphinxbfcode{\sphinxupquote{\_cols}}}
names of columns to select.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.selection.ColSelect method)@\spxentry{copy()}\spxextra{dalio.pipe.selection.ColSelect method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.selection.ColSelect.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.selection.ColSelect method)@\spxentry{transform()}\spxextra{dalio.pipe.selection.ColSelect method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.selection.ColSelect.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Selects the specified columns or returns data as is if no column
was specified.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Data of the same format as before but only only containing the
specified columns.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{DateSelect (class in dalio.pipe.selection)@\spxentry{DateSelect}\spxextra{class in dalio.pipe.selection}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.selection.DateSelect}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.selection.}}\sphinxbfcode{\sphinxupquote{DateSelect}}}{\emph{start=None}, \emph{end=None}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Select a date range.

This is commonly left as a local variable to control date range being
used at a piece of a graph.
\index{\_start (dalio.pipe.selection.DateSelect attribute)@\spxentry{\_start}\spxextra{dalio.pipe.selection.DateSelect attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.selection.DateSelect._start}}\pysigline{\sphinxbfcode{\sphinxupquote{\_start}}}
start date.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
pd.Timestamp

\end{description}\end{quote}

\end{fulllineitems}

\index{\_end (dalio.pipe.selection.DateSelect attribute)@\spxentry{\_end}\spxextra{dalio.pipe.selection.DateSelect attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.selection.DateSelect._end}}\pysigline{\sphinxbfcode{\sphinxupquote{\_end}}}
end date.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
pd.Timestamp

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.selection.DateSelect method)@\spxentry{copy()}\spxextra{dalio.pipe.selection.DateSelect method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.selection.DateSelect.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_end() (dalio.pipe.selection.DateSelect method)@\spxentry{set\_end()}\spxextra{dalio.pipe.selection.DateSelect method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.selection.DateSelect.set_end}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_end}}}{\emph{end}}{}
Set the \_end attribute

\end{fulllineitems}

\index{set\_start() (dalio.pipe.selection.DateSelect method)@\spxentry{set\_start()}\spxextra{dalio.pipe.selection.DateSelect method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.selection.DateSelect.set_start}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_start}}}{\emph{start}}{}
Set the \_start attribute

\end{fulllineitems}

\index{transform() (dalio.pipe.selection.DateSelect method)@\spxentry{transform()}\spxextra{dalio.pipe.selection.DateSelect method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.selection.DateSelect.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Slices time series into selected date range.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Time series of the same format as input containing a subset of
the original dates.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{dalio.model package}
\label{\detokenize{dalio.model:dalio-model-package}}\label{\detokenize{dalio.model::doc}}

\section{Submodules}
\label{\detokenize{dalio.model:submodules}}

\section{dalio.model.financial}
\label{\detokenize{dalio.model:module-dalio.model.financial}}\label{\detokenize{dalio.model:dalio-model-financial}}\index{dalio.model.financial (module)@\spxentry{dalio.model.financial}\spxextra{module}}
Define comps analysis models
\index{CompsData (class in dalio.model.financial)@\spxentry{CompsData}\spxextra{class in dalio.model.financial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.CompsData}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.financial.}}\sphinxbfcode{\sphinxupquote{CompsData}}}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.model.Model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.model.Model}}}}}

Get a ticker’s comps and their data.

This model has two sources: comps\_in and data\_in. comps\_in gets a
ticker’s comparative stocks. data\_in sources ticker data given a “TICKER”
keyword argument.
\index{run() (dalio.model.financial.CompsData method)@\spxentry{run()}\spxextra{dalio.model.financial.CompsData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.CompsData.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Run model.

This will be the bulk of subclass functionality. It is where all
data is sourced and processed.

\end{fulllineitems}


\end{fulllineitems}

\index{CompsFinancials (class in dalio.model.financial)@\spxentry{CompsFinancials}\spxextra{class in dalio.model.financial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.CompsFinancials}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.financial.}}\sphinxbfcode{\sphinxupquote{CompsFinancials}}}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.financial.CompsData}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.financial.CompsData}}}}}

Subclass to CompsData for getting stock price information

\end{fulllineitems}

\index{CompsInfo (class in dalio.model.financial)@\spxentry{CompsInfo}\spxextra{class in dalio.model.financial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.CompsInfo}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.financial.}}\sphinxbfcode{\sphinxupquote{CompsInfo}}}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.financial.CompsData}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.financial.CompsData}}}}}

Subclass to CompsData for getting comps stock information

\end{fulllineitems}

\index{MakeCriticalLine (class in dalio.model.financial)@\spxentry{MakeCriticalLine}\spxextra{class in dalio.model.financial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeCriticalLine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.financial.}}\sphinxbfcode{\sphinxupquote{MakeCriticalLine}}}{\emph{weight\_bounds=(\sphinxhyphen{}1}, \emph{1)}}{}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.model.Model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.model.Model}}}}}

Fit a critical line algorithm
This model takes in two sources: sample\_covariance and expected\_returns.
These are self\sphinxhyphen{}explanatory. The model calculates the algorithm for a set
of weight bounds.
.. attribute:: weight\_bounds
\begin{quote}

lower and upper bound for portfolio weights.
\begin{quote}\begin{description}
\item[{type}] \leavevmode
tuple

\end{description}\end{quote}
\end{quote}
\index{run() (dalio.model.financial.MakeCriticalLine method)@\spxentry{run()}\spxextra{dalio.model.financial.MakeCriticalLine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeCriticalLine.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get source data and create critical line algorithm

\end{fulllineitems}

\index{weight\_bounds (dalio.model.financial.MakeCriticalLine attribute)@\spxentry{weight\_bounds}\spxextra{dalio.model.financial.MakeCriticalLine attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeCriticalLine.weight_bounds}}\pysigline{\sphinxbfcode{\sphinxupquote{weight\_bounds}}\sphinxbfcode{\sphinxupquote{: Tuple{[}int{]}}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}


\end{fulllineitems}

\index{MakeEfficientFrontier (class in dalio.model.financial)@\spxentry{MakeEfficientFrontier}\spxextra{class in dalio.model.financial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.financial.}}\sphinxbfcode{\sphinxupquote{MakeEfficientFrontier}}}{\emph{weight\_bounds=(0}, \emph{1)}, \emph{gamma=0}}{}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.financial.MakeCriticalLine}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.financial.MakeCriticalLine}}}}}

Make an efficient frontier algorithm.
:param gamma: gamma optimization parameter.
:type gamma: int
\index{add\_constraint() (dalio.model.financial.MakeEfficientFrontier method)@\spxentry{add\_constraint()}\spxextra{dalio.model.financial.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier.add_constraint}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_constraint}}}{\emph{new\_constraint}}{}
Wrapper to PyPortfolioOpt BaseConvexOptimizer function
Add a new constraint to the optimisation problem. This constraint must
be linear and must be either an equality or simple inequality.
:param new\_constraint: the constraint to be added
:type new\_constraint: callable
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{AttributeError}} \textendash{} if new objective is not callable.

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_objective() (dalio.model.financial.MakeEfficientFrontier method)@\spxentry{add\_objective()}\spxextra{dalio.model.financial.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier.add_objective}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_objective}}}{\emph{new\_objective}, \emph{*args}, \emph{**kwargs}}{}
Wrapper to PyPortfolioOpt BaseConvexOptimizer function
Add a new term into the objective function. This term must be convex,
and built from cvxpy atomic functions.
:param new\_objective: the objective to be added
:type new\_objective: cp.Expression
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if the new objective is not supported.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{AttributeError}} \textendash{} if new objective is not callable.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_sector\_definitions() (dalio.model.financial.MakeEfficientFrontier method)@\spxentry{add\_sector\_definitions()}\spxextra{dalio.model.financial.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier.add_sector_definitions}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_sector\_definitions}}}{\emph{sector\_defs=None}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{add\_sector\_weight\_constraint() (dalio.model.financial.MakeEfficientFrontier method)@\spxentry{add\_sector\_weight\_constraint()}\spxextra{dalio.model.financial.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier.add_sector_weight_constraint}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_sector\_weight\_constraint}}}{\emph{sector=None}, \emph{constraint=\textquotesingle{}is\textquotesingle{}}, \emph{weight=0.5}}{}
\end{fulllineitems}

\index{add\_stock\_weight\_constraint() (dalio.model.financial.MakeEfficientFrontier method)@\spxentry{add\_stock\_weight\_constraint()}\spxextra{dalio.model.financial.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier.add_stock_weight_constraint}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_stock\_weight\_constraint}}}{\emph{ticker=None}, \emph{comparisson=\textquotesingle{}is\textquotesingle{}}, \emph{weight=0.5}}{}
Wrapper to add\_constraint method. Adds constraing on a named
ticker.
This is a much more intuitive interface to add constraints, as these
will often be stocks of an unknown order in a dataframe.
:param ticker: stock ticker or location to be constrained.
:type ticker: str, int
:param comparisson: constraing comparisson.
:type comparisson: str
:param weight: weight to constrain.
:type weight: float
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if any of the arguments are of an invalid type

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.model.financial.MakeEfficientFrontier method)@\spxentry{copy()}\spxextra{dalio.model.financial.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{}{}
Copy superclass, objectives and constraints.

\end{fulllineitems}

\index{gamma (dalio.model.financial.MakeEfficientFrontier attribute)@\spxentry{gamma}\spxextra{dalio.model.financial.MakeEfficientFrontier attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier.gamma}}\pysigline{\sphinxbfcode{\sphinxupquote{gamma}}\sphinxbfcode{\sphinxupquote{: int}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{run() (dalio.model.financial.MakeEfficientFrontier method)@\spxentry{run()}\spxextra{dalio.model.financial.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Make efficient frontier.
Create efficient frontier given a set of weight constraints.

\end{fulllineitems}

\index{weight\_bounds (dalio.model.financial.MakeEfficientFrontier attribute)@\spxentry{weight\_bounds}\spxextra{dalio.model.financial.MakeEfficientFrontier attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier.weight_bounds}}\pysigline{\sphinxbfcode{\sphinxupquote{weight\_bounds}}\sphinxbfcode{\sphinxupquote{: Tuple{[}int{]}}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}


\end{fulllineitems}

\index{OptimumPortfolio (class in dalio.model.financial)@\spxentry{OptimumPortfolio}\spxextra{class in dalio.model.financial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.OptimumPortfolio}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.financial.}}\sphinxbfcode{\sphinxupquote{OptimumPortfolio}}}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.model.Model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.model.Model}}}}}

Create optimum portfolio of stocks given dictionary of weights.
This model has two sources: weights\_in and data\_in. The weights\_in source
gets optimum weights for a set of tickers. The data\_in source gets price
data for these same tickers.
\index{run() (dalio.model.financial.OptimumPortfolio method)@\spxentry{run()}\spxextra{dalio.model.financial.OptimumPortfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.OptimumPortfolio.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Gets weights and uses them to create portfolio prices if weights
were kept constant.

\end{fulllineitems}


\end{fulllineitems}

\index{OptimumWeights (class in dalio.model.financial)@\spxentry{OptimumWeights}\spxextra{class in dalio.model.financial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.OptimumWeights}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.financial.}}\sphinxbfcode{\sphinxupquote{OptimumWeights}}}{\emph{weight\_bounds=(0}, \emph{1)}, \emph{gamma=0}}{}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.financial.MakeEfficientFrontier}}}}}, \sphinxcode{\sphinxupquote{dalio.base.builder.\_Builder}}

Get optimum portfolio weights from an efficient frontier.
This is also a builder with one piece: strategy. The strategy piece
refers to the optimization strategy.
\index{build\_model() (dalio.model.financial.OptimumWeights method)@\spxentry{build\_model()}\spxextra{dalio.model.financial.OptimumWeights method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.OptimumWeights.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}}{}
Assemble pieces into a model given some data

The data will opten be optional, but several builder models will
require it to be fitted on initialization. Which further shows why
builders are necessary for context\sphinxhyphen{}agnostic graphs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data that might be used to build the model.

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_name() (dalio.model.financial.OptimumWeights method)@\spxentry{check\_name()}\spxextra{dalio.model.financial.OptimumWeights method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.OptimumWeights.check_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_name}}}{\emph{param}, \emph{name}}{}
Check if name and parameter combination is valid.

This will always be called upon setting a new piece to ensure this
piece is present dictionary and that the name is valid. Subclasses
will often override this method to implement the name checks in
accordance to their specific name parameter combination options.
Notice that checks cannot be done on arguments before running the
\_Builder. This also can be called from outside of a \_Builder instance
to check for the validity of settings.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{piece}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the key in the piece dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name option to be set to the piece.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{gamma (dalio.model.financial.OptimumWeights attribute)@\spxentry{gamma}\spxextra{dalio.model.financial.OptimumWeights attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.OptimumWeights.gamma}}\pysigline{\sphinxbfcode{\sphinxupquote{gamma}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{run() (dalio.model.financial.OptimumWeights method)@\spxentry{run()}\spxextra{dalio.model.financial.OptimumWeights method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.OptimumWeights.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get efficient frontier, fit it to model and get weights

\end{fulllineitems}

\index{weight\_bounds (dalio.model.financial.OptimumWeights attribute)@\spxentry{weight\_bounds}\spxextra{dalio.model.financial.OptimumWeights attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.OptimumWeights.weight_bounds}}\pysigline{\sphinxbfcode{\sphinxupquote{weight\_bounds}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}


\end{fulllineitems}



\section{dalio.model.model}
\label{\detokenize{dalio.model:module-dalio.model.model}}\label{\detokenize{dalio.model:dalio-model-model}}\index{dalio.model.model (module)@\spxentry{dalio.model.model}\spxextra{module}}
Define Model class

Models are transformers that take in multiple inputs and has a single output.
Model instance can be much more flexible with additional options for differen
strategies of data processing and collection.
\index{Model (class in dalio.model.model)@\spxentry{Model}\spxextra{class in dalio.model.model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.model.Model}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.model.}}\sphinxbfcode{\sphinxupquote{Model}}}
Bases: \sphinxcode{\sphinxupquote{dalio.base.transformer.\_Transformer}}

Models represent data modification with multiple internal inputs and a
single internal output.
\index{\_source (dalio.model.model.Model attribute)@\spxentry{\_source}\spxextra{dalio.model.model.Model attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.model.Model._source}}\pysigline{\sphinxbfcode{\sphinxupquote{\_source}}}
dictionary of input data definitions

\end{fulllineitems}

\index{copy() (dalio.model.model.Model method)@\spxentry{copy()}\spxextra{dalio.model.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.model.Model.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (dalio.model.model.Model method)@\spxentry{run()}\spxextra{dalio.model.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.model.Model.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Run model.

This will be the bulk of subclass functionality. It is where all
data is sourced and processed.

\end{fulllineitems}

\index{set\_input() (dalio.model.model.Model method)@\spxentry{set\_input()}\spxextra{dalio.model.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.model.Model.set_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_input}}}{\emph{source\_name}, \emph{new\_input}}{}
Set a new connection to a data definition in dictionary entry
matching the key name.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} initialized item in sources dict.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{new\_input}} \textendash{} new source connection.

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{Raise:}] \leavevmode
KeyError: if input name is not present in sources dict.

\end{description}

\end{fulllineitems}

\index{with\_input() (dalio.model.model.Model method)@\spxentry{with\_input()}\spxextra{dalio.model.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.model.Model.with_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{with\_input}}}{\emph{source\_name}, \emph{new\_input}}{}
Return a copy of this model with the specified data definition
connection changed
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} initialized item in sources dict.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{new\_input}} \textendash{} new source connection.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{dalio.application package}
\label{\detokenize{dalio.application:dalio-application-package}}\label{\detokenize{dalio.application::doc}}

\section{Submodules}
\label{\detokenize{dalio.application:submodules}}

\section{dalio.application.application}
\label{\detokenize{dalio.application:module-dalio.application.application}}\label{\detokenize{dalio.application:dalio-application-application}}\index{dalio.application.application (module)@\spxentry{dalio.application.application}\spxextra{module}}
Define the Application class

While Models are normally the last stage of the processing chain, it
still has a single output, which might have limited value in itself.
Applications are tools used for the interpretation of some input and
outisde outputs. These can have a broad range of uses, from graphing to
real\sphinxhyphen{}time trading. The main functionality is in the .run() method, which
gets input data and interprets it as needed.
\index{Application (class in dalio.application.application)@\spxentry{Application}\spxextra{class in dalio.application.application}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.application.Application}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.application.}}\sphinxbfcode{\sphinxupquote{Application}}}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.model.Model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.model.Model}}}}}

Represent final representation of graph data through external entities.

Applications are transformations with one or more internal inputs and one
or more external outputs.
\index{\_out (dalio.application.application.Application attribute)@\spxentry{\_out}\spxextra{dalio.application.application.Application attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.application.Application._out}}\pysigline{\sphinxbfcode{\sphinxupquote{\_out}}}
dictionary of outisde output connections
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.application.application.Application method)@\spxentry{copy()}\spxextra{dalio.application.application.Application method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.application.Application.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (dalio.application.application.Application method)@\spxentry{run()}\spxextra{dalio.application.application.Application method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.application.Application.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Run application.

This will be the bulk of subclass functionality. It is where all
data is sourced, processed and output.

\end{fulllineitems}

\index{set\_output() (dalio.application.application.Application method)@\spxentry{set\_output()}\spxextra{dalio.application.application.Application method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.application.Application.set_output}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_output}}}{\emph{output\_name}, \emph{new\_output}}{}
Set a new output to data definition in dictionary entry
matching the name
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the name of the output from the output dict.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{new\_output}} \textendash{} new External source to be set as the output.

\end{itemize}

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} if name is not in the output dict.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if the new output is not an instance of External.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{with\_output() (dalio.application.application.Application method)@\spxentry{with\_output()}\spxextra{dalio.application.application.Application method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.application.Application.with_output}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{with\_output}}}{\emph{output\_name}, \emph{new\_output}}{}
Return a copy of this model with the specified data definition
output changed
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the name of the output from the output dict.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{new\_output}} \textendash{} new External source to be set as the output.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{dalio.application.graphers}
\label{\detokenize{dalio.application:module-dalio.application.graphers}}\label{\detokenize{dalio.application:dalio-application-graphers}}\index{dalio.application.graphers (module)@\spxentry{dalio.application.graphers}\spxextra{module}}
Applications based on graphing input data
\index{ForecastGrapher (class in dalio.application.graphers)@\spxentry{ForecastGrapher}\spxextra{class in dalio.application.graphers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.ForecastGrapher}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.graphers.}}\sphinxbfcode{\sphinxupquote{ForecastGrapher}}}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.graphers.Grapher}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.graphers.Grapher}}}}}

Application to graph data and a forecast horizon

This Application has two sources data\_in and forecast\_in. The data\sphinxhyphen{}in
source is explained in Grapher. The forecast\_in source gets a forecast
data to be graphed.
\index{run() (dalio.application.graphers.ForecastGrapher method)@\spxentry{run()}\spxextra{dalio.application.graphers.ForecastGrapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.ForecastGrapher.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get data, its forecast and plot both

\end{fulllineitems}


\end{fulllineitems}

\index{Grapher (class in dalio.application.graphers)@\spxentry{Grapher}\spxextra{class in dalio.application.graphers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.Grapher}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.graphers.}}\sphinxbfcode{\sphinxupquote{Grapher}}}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.application.Application}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.application.Application}}}}}

Base grapher class.

Does basic graphing, assuming data does not require any processing before
being passed onto an external grapher.

This Application has one source: data\_in. The data\_in source gets
internal data to be graphed.

This Application has one output: data\_out. The data\_out output represents
an external graph.
\index{run() (dalio.application.graphers.Grapher method)@\spxentry{run()}\spxextra{dalio.application.graphers.Grapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.Grapher.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Gets data input and plots it

\end{fulllineitems}


\end{fulllineitems}

\index{LMGrapher (class in dalio.application.graphers)@\spxentry{LMGrapher}\spxextra{class in dalio.application.graphers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.LMGrapher}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.graphers.}}\sphinxbfcode{\sphinxupquote{LMGrapher}}}{\emph{legend=None}}{}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.graphers.Grapher}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.graphers.Grapher}}}}}

Application to graph data and a linear model fitted to it.

This Application has two sources data\_in and linear\_model. The data\sphinxhyphen{}in
source is explained in Grapher. The linear\_model source is a fitted
linear model with intercept and coefficient data.
\index{\_legend (dalio.application.graphers.LMGrapher attribute)@\spxentry{\_legend}\spxextra{dalio.application.graphers.LMGrapher attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.LMGrapher._legend}}\pysigline{\sphinxbfcode{\sphinxupquote{\_legend}}}
legend position on graph.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str, None

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (dalio.application.graphers.LMGrapher method)@\spxentry{run()}\spxextra{dalio.application.graphers.LMGrapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.LMGrapher.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get data, its fitted coefficients and intercepts and graph them.

\end{fulllineitems}


\end{fulllineitems}

\index{PandasTSGrapher (class in dalio.application.graphers)@\spxentry{PandasTSGrapher}\spxextra{class in dalio.application.graphers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.PandasTSGrapher}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.graphers.}}\sphinxbfcode{\sphinxupquote{PandasTSGrapher}}}{\emph{y=None}, \emph{legend=None}}{}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.graphers.PandasXYGrapher}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.graphers.PandasXYGrapher}}}}}

Graphs a pandas time series

Same functionality as parent class with stricter inputs.

\end{fulllineitems}

\index{PandasXYGrapher (class in dalio.application.graphers)@\spxentry{PandasXYGrapher}\spxextra{class in dalio.application.graphers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.PandasXYGrapher}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.graphers.}}\sphinxbfcode{\sphinxupquote{PandasXYGrapher}}}{\emph{x=None}, \emph{y=None}, \emph{legend=None}}{}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.graphers.Grapher}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.graphers.Grapher}}}}}

Graph data from a pandas dataframe with option of selecting columns
used as axis
\index{\_x (dalio.application.graphers.PandasXYGrapher attribute)@\spxentry{\_x}\spxextra{dalio.application.graphers.PandasXYGrapher attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.PandasXYGrapher._x}}\pysigline{\sphinxbfcode{\sphinxupquote{\_x}}}
name of column to be used for x\sphinxhyphen{}axis.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_y (dalio.application.graphers.PandasXYGrapher attribute)@\spxentry{\_y}\spxextra{dalio.application.graphers.PandasXYGrapher attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.PandasXYGrapher._y}}\pysigline{\sphinxbfcode{\sphinxupquote{\_y}}}
name of column to be used for y\sphinxhyphen{}axis.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_legend (dalio.application.graphers.PandasXYGrapher attribute)@\spxentry{\_legend}\spxextra{dalio.application.graphers.PandasXYGrapher attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.PandasXYGrapher._legend}}\pysigline{\sphinxbfcode{\sphinxupquote{\_legend}}}
legend position. None by default
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str, None

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (dalio.application.graphers.PandasXYGrapher method)@\spxentry{run()}\spxextra{dalio.application.graphers.PandasXYGrapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.PandasXYGrapher.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get data, separate columns and feed it to data output graph

\end{fulllineitems}


\end{fulllineitems}

\index{VaRGrapher (class in dalio.application.graphers)@\spxentry{VaRGrapher}\spxextra{class in dalio.application.graphers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.VaRGrapher}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.graphers.}}\sphinxbfcode{\sphinxupquote{VaRGrapher}}}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.graphers.Grapher}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.graphers.Grapher}}}}}

Application to visualize Value at Risk
\index{run() (dalio.application.graphers.VaRGrapher method)@\spxentry{run()}\spxextra{dalio.application.graphers.VaRGrapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.VaRGrapher.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get value at risk data, plot returns, value at risk lines and
exceptions at their maximum exedence.

Thank you for the creators of the arch package for the amazing
visulaization idea!

\end{fulllineitems}


\end{fulllineitems}



\section{dalio.application.printers}
\label{\detokenize{dalio.application:module-dalio.application.printers}}\label{\detokenize{dalio.application:dalio-application-printers}}\index{dalio.application.printers (module)@\spxentry{dalio.application.printers}\spxextra{module}}
Print data onto an external output
\index{FilePrinter (class in dalio.application.printers)@\spxentry{FilePrinter}\spxextra{class in dalio.application.printers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.printers.FilePrinter}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.printers.}}\sphinxbfcode{\sphinxupquote{FilePrinter}}}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.application.Application}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.application.Application}}}}}

Application to print data onto a file

This application has one source: data\_in. The data\_in source is the data
to be printed.

This application has one output: data\_out. The data\_out output is the
external output to print the data to.
\index{run() (dalio.application.printers.FilePrinter method)@\spxentry{run()}\spxextra{dalio.application.printers.FilePrinter method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.printers.FilePrinter.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Gets data and prints it

\end{fulllineitems}


\end{fulllineitems}



\chapter{dalio.ops module}
\label{\detokenize{dalio.ops:module-dalio.ops}}\label{\detokenize{dalio.ops:dalio-ops-module}}\label{\detokenize{dalio.ops::doc}}\index{dalio.ops (module)@\spxentry{dalio.ops}\spxextra{module}}
Define various operations
\index{get\_comps\_by\_sic() (in module dalio.ops)@\spxentry{get\_comps\_by\_sic()}\spxextra{in module dalio.ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.ops:dalio.ops.get_comps_by_sic}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.ops.}}\sphinxbfcode{\sphinxupquote{get\_comps\_by\_sic}}}{\emph{data}, \emph{ticker}, \emph{max\_ticks=None}}{}
Get an equity’s comps based on market cap and sic code similarity

This has the major flaw of getting too many comps for common industries.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} data containing all possible comparisson
candidates.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ticker}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} ticker of main stock.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{max\_ticks}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} maximum number of tickers to return.

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} if stock is not present in data.

\end{description}\end{quote}

\end{fulllineitems}

\index{index\_cols() (in module dalio.ops)@\spxentry{index\_cols()}\spxextra{in module dalio.ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.ops:dalio.ops.index_cols}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.ops.}}\sphinxbfcode{\sphinxupquote{index\_cols}}}{\emph{df}, \emph{i=100}}{}
Index columns at some value

\end{fulllineitems}

\index{risk\_metrics() (in module dalio.ops)@\spxentry{risk\_metrics()}\spxextra{in module dalio.ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.ops:dalio.ops.risk_metrics}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.ops.}}\sphinxbfcode{\sphinxupquote{risk\_metrics}}}{\emph{data}, \emph{lam}}{}
Apply the basic RiskMetrics (EWMA) continuous volatility measure to a
a dataframe
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{lam}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} lambda parameter

\item[{Returns}] \leavevmode
A copy of data with the continuous volatility of each value

\end{description}\end{quote}

\end{fulllineitems}



\chapter{dalio.base}
\label{\detokenize{dalio.base:dalio-base}}\label{\detokenize{dalio.base::doc}}

\section{Submodules}
\label{\detokenize{dalio.base:submodules}}

\section{dalio.base.builder module}
\label{\detokenize{dalio.base:module-dalio.base.builder}}\label{\detokenize{dalio.base:dalio-base-builder-module}}\index{dalio.base.builder (module)@\spxentry{dalio.base.builder}\spxextra{module}}
Define extra utility classes used throughout the package

These classes implement certain interfaces used in specific cases and are not
constrained an object’s parent class.


\section{dalio.base.constants module}
\label{\detokenize{dalio.base:module-dalio.base.constants}}\label{\detokenize{dalio.base:dalio-base-constants-module}}\index{dalio.base.constants (module)@\spxentry{dalio.base.constants}\spxextra{module}}
Define constant terms

In order to maintain name integrity throughout graphs, constants are used
instead of any string name for variables that were created or will be usued in
any \_Transformer instance before or after the current one. These are often
column names for pandas DataFrames, though can be anything that is or will be
used to identify data throughout the graph.


\section{dalio.base.datadef module}
\label{\detokenize{dalio.base:module-dalio.base.datadef}}\label{\detokenize{dalio.base:dalio-base-datadef-module}}\index{dalio.base.datadef (module)@\spxentry{dalio.base.datadef}\spxextra{module}}
Defines DataDef base class

DataDef instances describe data inputs throughout the graph and ensure the
integrity of data continuously. These are composed of various validators that
serve both to describe approved data and check for whether data passes a test.


\section{dalio.base.node module}
\label{\detokenize{dalio.base:module-dalio.base.node}}\label{\detokenize{dalio.base:dalio-base-node-module}}\index{dalio.base.node (module)@\spxentry{dalio.base.node}\spxextra{module}}
Defines Node abstract class

Nodes are the key building blocks of your model as they represent any data
that passes thorugh it. These are usued in subsequent classes to describe and
manage data.


\section{dalio.base.transformer module}
\label{\detokenize{dalio.base:module-dalio.base.transformer}}\label{\detokenize{dalio.base:dalio-base-transformer-module}}\index{dalio.base.transformer (module)@\spxentry{dalio.base.transformer}\spxextra{module}}
Define Transformer class

Transformers are a base class that represents any kind of data modification.
These interact with DataOrigin instances as they are key to their input and
output integrity. A set\_source() method sets the source of the input, the
.run() method cannot be executed if the input”s source is not set.


\section{Module contents}
\label{\detokenize{dalio.base:module-dalio.base}}\label{\detokenize{dalio.base:module-contents}}\index{dalio.base (module)@\spxentry{dalio.base}\spxextra{module}}
import classes


\chapter{dalio.validator}
\label{\detokenize{dalio.validator:dalio-validator}}\label{\detokenize{dalio.validator::doc}}

\section{Submodules}
\label{\detokenize{dalio.validator:submodules}}

\section{dalio.validator.array\_val module}
\label{\detokenize{dalio.validator:module-dalio.validator.array_val}}\label{\detokenize{dalio.validator:dalio-validator-array-val-module}}\index{dalio.validator.array\_val (module)@\spxentry{dalio.validator.array\_val}\spxextra{module}}
Definte validators applied to array\sphinxhyphen{}like inputs
\index{HAS\_DIMS (class in dalio.validator.array\_val)@\spxentry{HAS\_DIMS}\spxextra{class in dalio.validator.array\_val}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.array_val.HAS_DIMS}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.array\_val.}}\sphinxbfcode{\sphinxupquote{HAS\_DIMS}}}{\emph{dims}, \emph{comparisson=\textquotesingle{}==\textquotesingle{}}}{}
Bases: {\hyperref[\detokenize{dalio.validator:dalio.validator.validator.Validator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.validator.validator.Validator}}}}}

Check if an array has a number of dimensions
\index{\_dims (dalio.validator.array\_val.HAS\_DIMS attribute)@\spxentry{\_dims}\spxextra{dalio.validator.array\_val.HAS\_DIMS attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.array_val.HAS_DIMS._dims}}\pysigline{\sphinxbfcode{\sphinxupquote{\_dims}}}
number of dimensions
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{\_comparisson (dalio.validator.array\_val.HAS\_DIMS attribute)@\spxentry{\_comparisson}\spxextra{dalio.validator.array\_val.HAS\_DIMS attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.array_val.HAS_DIMS._comparisson}}\pysigline{\sphinxbfcode{\sphinxupquote{\_comparisson}}}
which comparisson to perform
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (dalio.validator.array\_val.HAS\_DIMS method)@\spxentry{validate()}\spxextra{dalio.validator.array\_val.HAS\_DIMS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.array_val.HAS_DIMS.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{\emph{data}}{}
Validate data

Check if data fits a certain description.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A description of any errors in the data according to this
specific validation condition, and None if data is valid.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{dalio.validator.base\_val module}
\label{\detokenize{dalio.validator:module-dalio.validator.base_val}}\label{\detokenize{dalio.validator:dalio-validator-base-val-module}}\index{dalio.validator.base\_val (module)@\spxentry{dalio.validator.base\_val}\spxextra{module}}
Define Validators used for general python objects
\index{ELEMS\_TYPE (class in dalio.validator.base\_val)@\spxentry{ELEMS\_TYPE}\spxextra{class in dalio.validator.base\_val}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.base_val.ELEMS_TYPE}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.base\_val.}}\sphinxbfcode{\sphinxupquote{ELEMS\_TYPE}}}{\emph{t}}{}
Bases: {\hyperref[\detokenize{dalio.validator:dalio.validator.base_val.HAS_ATTR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.validator.base\_val.HAS\_ATTR}}}}}

Checks if all elements of an iterator is of a certain type.
\index{\_t (dalio.validator.base\_val.ELEMS\_TYPE attribute)@\spxentry{\_t}\spxextra{dalio.validator.base\_val.ELEMS\_TYPE attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.base_val.ELEMS_TYPE._t}}\pysigline{\sphinxbfcode{\sphinxupquote{\_t}}}
type to check iterator’s elements for
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
type, tuple

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (dalio.validator.base\_val.ELEMS\_TYPE method)@\spxentry{validate()}\spxextra{dalio.validator.base\_val.ELEMS\_TYPE method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.base_val.ELEMS_TYPE.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{\emph{data}}{}
Validates data if it is an iterable with all elements of type
self.\_t

\end{fulllineitems}


\end{fulllineitems}

\index{HAS\_ATTR (class in dalio.validator.base\_val)@\spxentry{HAS\_ATTR}\spxextra{class in dalio.validator.base\_val}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.base_val.HAS_ATTR}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.base\_val.}}\sphinxbfcode{\sphinxupquote{HAS\_ATTR}}}{\emph{attr}}{}
Bases: {\hyperref[\detokenize{dalio.validator:dalio.validator.validator.Validator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.validator.validator.Validator}}}}}

Checks if data has an attribute
\index{\_attr (dalio.validator.base\_val.HAS\_ATTR attribute)@\spxentry{\_attr}\spxextra{dalio.validator.base\_val.HAS\_ATTR attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.base_val.HAS_ATTR._attr}}\pysigline{\sphinxbfcode{\sphinxupquote{\_attr}}}
attribute to check for
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (dalio.validator.base\_val.HAS\_ATTR method)@\spxentry{validate()}\spxextra{dalio.validator.base\_val.HAS\_ATTR method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.base_val.HAS_ATTR.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{\emph{data}}{}
Validates data if it contains attribute self.\_attr

\end{fulllineitems}


\end{fulllineitems}

\index{IS\_TYPE (class in dalio.validator.base\_val)@\spxentry{IS\_TYPE}\spxextra{class in dalio.validator.base\_val}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.base_val.IS_TYPE}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.base\_val.}}\sphinxbfcode{\sphinxupquote{IS\_TYPE}}}{\emph{t}}{}
Bases: {\hyperref[\detokenize{dalio.validator:dalio.validator.validator.Validator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.validator.validator.Validator}}}}}

Checks if data is of a certain type
\begin{description}
\item[{Attribute:}] \leavevmode
t (type): type of data to check for

\end{description}
\index{validate() (dalio.validator.base\_val.IS\_TYPE method)@\spxentry{validate()}\spxextra{dalio.validator.base\_val.IS\_TYPE method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.base_val.IS_TYPE.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{\emph{data}}{}
Validates data if it is of type self.\_t

\end{fulllineitems}


\end{fulllineitems}



\section{dalio.validator.pandas\_val module}
\label{\detokenize{dalio.validator:module-dalio.validator.pandas_val}}\label{\detokenize{dalio.validator:dalio-validator-pandas-val-module}}\index{dalio.validator.pandas\_val (module)@\spxentry{dalio.validator.pandas\_val}\spxextra{module}}\index{HAS\_COLS (class in dalio.validator.pandas\_val)@\spxentry{HAS\_COLS}\spxextra{class in dalio.validator.pandas\_val}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_COLS}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.pandas\_val.}}\sphinxbfcode{\sphinxupquote{HAS\_COLS}}}{\emph{cols}}{}
Bases: {\hyperref[\detokenize{dalio.validator:dalio.validator.pandas_val.IS_PD_DF}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.validator.pandas\_val.IS\_PD\_DF}}}}}

Checks if data has certain column names
\index{\_cols (dalio.validator.pandas\_val.HAS\_COLS attribute)@\spxentry{\_cols}\spxextra{dalio.validator.pandas\_val.HAS\_COLS attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_COLS._cols}}\pysigline{\sphinxbfcode{\sphinxupquote{\_cols}}}
list of column names to check

\end{fulllineitems}

\index{validate() (dalio.validator.pandas\_val.HAS\_COLS method)@\spxentry{validate()}\spxextra{dalio.validator.pandas\_val.HAS\_COLS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_COLS.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{\emph{data}}{}
Validates data if all the columns in self.\_cols is present in the
dataframe

\end{fulllineitems}


\end{fulllineitems}

\index{HAS\_INDEX\_NAMES (class in dalio.validator.pandas\_val)@\spxentry{HAS\_INDEX\_NAMES}\spxextra{class in dalio.validator.pandas\_val}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_INDEX_NAMES}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.pandas\_val.}}\sphinxbfcode{\sphinxupquote{HAS\_INDEX\_NAMES}}}{\emph{names}, \emph{axis=0}}{}
Bases: {\hyperref[\detokenize{dalio.validator:dalio.validator.pandas_val.IS_PD_DF}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.validator.pandas\_val.IS\_PD\_DF}}}}}

Checks if an axis has specified names
\index{\_names (dalio.validator.pandas\_val.HAS\_INDEX\_NAMES attribute)@\spxentry{\_names}\spxextra{dalio.validator.pandas\_val.HAS\_INDEX\_NAMES attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_INDEX_NAMES._names}}\pysigline{\sphinxbfcode{\sphinxupquote{\_names}}}
names to check for

\end{fulllineitems}

\index{\_axis (dalio.validator.pandas\_val.HAS\_INDEX\_NAMES attribute)@\spxentry{\_axis}\spxextra{dalio.validator.pandas\_val.HAS\_INDEX\_NAMES attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_INDEX_NAMES._axis}}\pysigline{\sphinxbfcode{\sphinxupquote{\_axis}}}
axis to check for names

\end{fulllineitems}

\index{validate() (dalio.validator.pandas\_val.HAS\_INDEX\_NAMES method)@\spxentry{validate()}\spxextra{dalio.validator.pandas\_val.HAS\_INDEX\_NAMES method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_INDEX_NAMES.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{\emph{data}}{}
Validates data if specified axis has the specified names

\end{fulllineitems}


\end{fulllineitems}

\index{HAS\_IN\_COLS (class in dalio.validator.pandas\_val)@\spxentry{HAS\_IN\_COLS}\spxextra{class in dalio.validator.pandas\_val}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_IN_COLS}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.pandas\_val.}}\sphinxbfcode{\sphinxupquote{HAS\_IN\_COLS}}}{\emph{items}, \emph{cols=None}}{}
Bases: {\hyperref[\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_COLS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.validator.pandas\_val.HAS\_COLS}}}}}

Check if certain items are present in certain columns
\index{\_cols (dalio.validator.pandas\_val.HAS\_IN\_COLS attribute)@\spxentry{\_cols}\spxextra{dalio.validator.pandas\_val.HAS\_IN\_COLS attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_IN_COLS._cols}}\pysigline{\sphinxbfcode{\sphinxupquote{\_cols}}}
See base class

\end{fulllineitems}

\index{\_items (dalio.validator.pandas\_val.HAS\_IN\_COLS attribute)@\spxentry{\_items}\spxextra{dalio.validator.pandas\_val.HAS\_IN\_COLS attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_IN_COLS._items}}\pysigline{\sphinxbfcode{\sphinxupquote{\_items}}}
items that must be present in each of the specified columns

\end{fulllineitems}

\index{validate() (dalio.validator.pandas\_val.HAS\_IN\_COLS method)@\spxentry{validate()}\spxextra{dalio.validator.pandas\_val.HAS\_IN\_COLS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_IN_COLS.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{\emph{data}}{}
Validates data if items in self.\_items are not present in specified
columns. Specified columns are all columns if self.\_cols is None.

\end{fulllineitems}


\end{fulllineitems}

\index{IS\_PD\_DF (class in dalio.validator.pandas\_val)@\spxentry{IS\_PD\_DF}\spxextra{class in dalio.validator.pandas\_val}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.IS_PD_DF}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.pandas\_val.}}\sphinxbfcode{\sphinxupquote{IS\_PD\_DF}}}
Bases: {\hyperref[\detokenize{dalio.validator:dalio.validator.base_val.IS_TYPE}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.validator.base\_val.IS\_TYPE}}}}}

Checks if data is a pandas dataframe


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{See~base~class}}}
\end{fulllineitems}


\end{fulllineitems}

\index{IS\_PD\_TS (class in dalio.validator.pandas\_val)@\spxentry{IS\_PD\_TS}\spxextra{class in dalio.validator.pandas\_val}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.IS_PD_TS}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.pandas\_val.}}\sphinxbfcode{\sphinxupquote{IS\_PD\_TS}}}
Bases: {\hyperref[\detokenize{dalio.validator:dalio.validator.base_val.IS_TYPE}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.validator.base\_val.IS\_TYPE}}}}}

Checks if data is a pandas time series
\index{validate() (dalio.validator.pandas\_val.IS\_PD\_TS method)@\spxentry{validate()}\spxextra{dalio.validator.pandas\_val.IS\_PD\_TS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.IS_PD_TS.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{\emph{data}}{}
Validates data if it’s index is of type pandas.DateTimeIndex

\end{fulllineitems}


\end{fulllineitems}



\section{dalio.validator.presets module}
\label{\detokenize{dalio.validator:module-dalio.validator.presets}}\label{\detokenize{dalio.validator:dalio-validator-presets-module}}\index{dalio.validator.presets (module)@\spxentry{dalio.validator.presets}\spxextra{module}}
Define Validator collection presets

These are useful to describe very specific data characteristics commonly used
in some analysis.


\section{dalio.validator.validator module}
\label{\detokenize{dalio.validator:module-dalio.validator.validator}}\label{\detokenize{dalio.validator:dalio-validator-validator-module}}\index{dalio.validator.validator (module)@\spxentry{dalio.validator.validator}\spxextra{module}}
Define Validator class

Validators are the building blocks of data integrity in the graph. As
modularity is key, validators ensure that the data that enters a node is what
it is mean to be or that errors are targeted to make debugging easier.
\index{Validator (class in dalio.validator.validator)@\spxentry{Validator}\spxextra{class in dalio.validator.validator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.validator.Validator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.validator.}}\sphinxbfcode{\sphinxupquote{Validator}}}{\emph{fatal=True}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Check for some characteristic of a piece of data

Validators can have any attribute needed, but functionality is stored
in u the .validate function, which returns any errors in the data.
\index{fatal (dalio.validator.validator.Validator attribute)@\spxentry{fatal}\spxextra{dalio.validator.validator.Validator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.validator.Validator.fatal}}\pysigline{\sphinxbfcode{\sphinxupquote{fatal}}}
Whether if invalid data is fatal. Decides whether
invalid data can still be passed on (with a warning) or if it is
grounds to stop the execution of the graph. False by default.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{test\_desc (dalio.validator.validator.Validator attribute)@\spxentry{test\_desc}\spxextra{dalio.validator.validator.Validator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.validator.Validator.test_desc}}\pysigline{\sphinxbfcode{\sphinxupquote{test\_desc}}}
Description of tests performed on data
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{fatal (dalio.validator.validator.Validator attribute)@\spxentry{fatal}\spxextra{dalio.validator.validator.Validator attribute}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{fatal}}\sphinxbfcode{\sphinxupquote{: bool}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{fatal\_off() (dalio.validator.validator.Validator method)@\spxentry{fatal\_off()}\spxextra{dalio.validator.validator.Validator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.validator.Validator.fatal_off}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fatal\_off}}}{}{}
Turn fatal off and return self

\end{fulllineitems}

\index{fatal\_on() (dalio.validator.validator.Validator method)@\spxentry{fatal\_on()}\spxextra{dalio.validator.validator.Validator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.validator.Validator.fatal_on}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fatal\_on}}}{}{}
Turn fatal on and return self

\end{fulllineitems}

\index{is\_on (dalio.validator.validator.Validator attribute)@\spxentry{is\_on}\spxextra{dalio.validator.validator.Validator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.validator.Validator.is_on}}\pysigline{\sphinxbfcode{\sphinxupquote{is\_on}}\sphinxbfcode{\sphinxupquote{: bool}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{test\_desc (dalio.validator.validator.Validator attribute)@\spxentry{test\_desc}\spxextra{dalio.validator.validator.Validator attribute}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{test\_desc}}\sphinxbfcode{\sphinxupquote{: str}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{validate() (dalio.validator.validator.Validator method)@\spxentry{validate()}\spxextra{dalio.validator.validator.Validator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.validator.Validator.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{\emph{data}}{}
Validate data

Check if data fits a certain description.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A description of any errors in the data according to this
specific validation condition, and None if data is valid.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Module contents}
\label{\detokenize{dalio.validator:module-dalio.validator}}\label{\detokenize{dalio.validator:module-contents}}\index{dalio.validator (module)@\spxentry{dalio.validator}\spxextra{module}}

\chapter{dalio.util}
\label{\detokenize{dalio.util:dalio-util}}\label{\detokenize{dalio.util::doc}}

\section{Submodules}
\label{\detokenize{dalio.util:submodules}}

\section{dalio.util.plotting\_utils module}
\label{\detokenize{dalio.util:module-dalio.util.plotting_utils}}\label{\detokenize{dalio.util:dalio-util-plotting-utils-module}}\index{dalio.util.plotting\_utils (module)@\spxentry{dalio.util.plotting\_utils}\spxextra{module}}
Plotting utilities

Thank you for the creators of pypfopt for the wonderful code!
\index{plot\_covariance() (in module dalio.util.plotting\_utils)@\spxentry{plot\_covariance()}\spxextra{in module dalio.util.plotting\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.plotting_utils.plot_covariance}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.plotting\_utils.}}\sphinxbfcode{\sphinxupquote{plot\_covariance}}}{\emph{cov\_matrix}, \emph{plot\_correlation=False}, \emph{show\_tickers=True}, \emph{ax=None}}{}
Generate a basic plot of the covariance (or correlation) matrix,
given a covariance matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cov\_matrix}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} covariance matrix

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plot\_correlation}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether to plot the correlation matrix
instead, defaults to False. Optional.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{show\_tickers}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether to use tickers as labels (not
recommended for large portfolios). Optional. Defaults to True.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{matplolib.axis}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Axis to plot on. Optional. New axis will
be created if none is specified.

\end{itemize}

\item[{Returns}] \leavevmode
matplotlib axis

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_dendrogram() (in module dalio.util.plotting\_utils)@\spxentry{plot\_dendrogram()}\spxextra{in module dalio.util.plotting\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.plotting_utils.plot_dendrogram}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.plotting\_utils.}}\sphinxbfcode{\sphinxupquote{plot\_dendrogram}}}{\emph{hrp}, \emph{show\_tickers=True}, \emph{ax=None}, \emph{**kwargs}}{}
Plot the clusters in the form of a dendrogram.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hrp}} \textendash{} HRPpt object that has already been optimized.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{show\_tickers}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether to use tickers as labels (not
recommended for large portfolios). Optional. Defaults to True.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{matplolib.axis}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Axis to plot on. Optional. New axis will
be created if none is specified.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} optional parameters for main graph.

\end{itemize}

\item[{Returns}] \leavevmode
matplotlib axis

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_efficient\_frontier() (in module dalio.util.plotting\_utils)@\spxentry{plot\_efficient\_frontier()}\spxextra{in module dalio.util.plotting\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.plotting_utils.plot_efficient_frontier}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.plotting\_utils.}}\sphinxbfcode{\sphinxupquote{plot\_efficient\_frontier}}}{\emph{cla}, \emph{points=100}, \emph{show\_assets=True}, \emph{ax=None}, \emph{**kwargs}}{}
Plot the efficient frontier based on a CLA object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{points}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of points to plot. Optional. Defaults to 100

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{show\_assets}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether we should plot the asset risks/returns
also. Optional. Defaults to True.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{matplolib.axis}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Axis to plot on. Optional. New axis will
be created if none is specified.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} optional parameters for main graph.

\end{itemize}

\item[{Returns}] \leavevmode
matplotlib axis

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_weights() (in module dalio.util.plotting\_utils)@\spxentry{plot\_weights()}\spxextra{in module dalio.util.plotting\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.plotting_utils.plot_weights}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.plotting\_utils.}}\sphinxbfcode{\sphinxupquote{plot\_weights}}}{\emph{weights}, \emph{ax=None}, \emph{**kwargs}}{}
Plot the portfolio weights as a horizontal bar chart
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weights}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} the weights outputted by any PyPortfolioOpt
optimiser.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{matplolib.axis}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Axis to plot on. Optional. New axis will
be created if none is specified.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} optional parameters for main graph.

\end{itemize}

\item[{Returns}] \leavevmode
matplotlib axis

\end{description}\end{quote}

\end{fulllineitems}



\section{dalio.util.processing\_utils module}
\label{\detokenize{dalio.util:module-dalio.util.processing_utils}}\label{\detokenize{dalio.util:dalio-util-processing-utils-module}}\index{dalio.util.processing\_utils (module)@\spxentry{dalio.util.processing\_utils}\spxextra{module}}
Data processing utilities
\index{process\_cols() (in module dalio.util.processing\_utils)@\spxentry{process\_cols()}\spxextra{in module dalio.util.processing\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.processing_utils.process_cols}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.processing\_utils.}}\sphinxbfcode{\sphinxupquote{process\_cols}}}{\emph{cols}}{}
Standardize input columns

\end{fulllineitems}

\index{process\_date() (in module dalio.util.processing\_utils)@\spxentry{process\_date()}\spxextra{in module dalio.util.processing\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.processing_utils.process_date}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.processing\_utils.}}\sphinxbfcode{\sphinxupquote{process\_date}}}{\emph{date}}{}
Standardize input date
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the type of the date parameter cannot be converted to
    a pandas timestamp

\end{description}\end{quote}

\end{fulllineitems}

\index{process\_new\_colnames() (in module dalio.util.processing\_utils)@\spxentry{process\_new\_colnames()}\spxextra{in module dalio.util.processing\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.processing_utils.process_new_colnames}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.processing\_utils.}}\sphinxbfcode{\sphinxupquote{process\_new\_colnames}}}{\emph{cols}, \emph{new\_cols}}{}
Get new column names based on the column parameter

\end{fulllineitems}

\index{process\_new\_df() (in module dalio.util.processing\_utils)@\spxentry{process\_new\_df()}\spxextra{in module dalio.util.processing\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.processing_utils.process_new_df}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.processing\_utils.}}\sphinxbfcode{\sphinxupquote{process\_new\_df}}}{\emph{df1}, \emph{df2}, \emph{cols}, \emph{new\_cols}}{}
Process new dataframe given columns and new column names
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df1}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} first dataframe.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df2}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dataframe to join or get columns from

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}) \textendash{} iterable of columns being targetted.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{new\_cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}) \textendash{} iterable of new column names.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{dalio.util.translation\_utils module}
\label{\detokenize{dalio.util:module-dalio.util.translation_utils}}\label{\detokenize{dalio.util:dalio-util-translation-utils-module}}\index{dalio.util.translation\_utils (module)@\spxentry{dalio.util.translation\_utils}\spxextra{module}}
Translation utilities
\index{translate\_df() (in module dalio.util.translation\_utils)@\spxentry{translate\_df()}\spxextra{in module dalio.util.translation\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.translation_utils.translate_df}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.translation\_utils.}}\sphinxbfcode{\sphinxupquote{translate\_df}}}{\emph{translator}, \emph{df}, \emph{inplace=False}}{}
Translate dataframe column and index names in accordance to translator
dictionary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{translator}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} dictionary of \{original: translated\} key value
pairs.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dataframe to have rows and columns translated.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inplace}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether to perform operation inplace or return a
translated copy. Optional. Defaults to False.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{Module contents}
\label{\detokenize{dalio.util:module-dalio.util}}\label{\detokenize{dalio.util:module-contents}}\index{dalio.util (module)@\spxentry{dalio.util}\spxextra{module}}\index{process\_cols() (in module dalio.util)@\spxentry{process\_cols()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.process_cols}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{process\_cols}}}{\emph{cols}}{}
Standardize input columns

\end{fulllineitems}

\index{process\_new\_colnames() (in module dalio.util)@\spxentry{process\_new\_colnames()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.process_new_colnames}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{process\_new\_colnames}}}{\emph{cols}, \emph{new\_cols}}{}
Get new column names based on the column parameter

\end{fulllineitems}

\index{process\_date() (in module dalio.util)@\spxentry{process\_date()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.process_date}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{process\_date}}}{\emph{date}}{}
Standardize input date
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the type of the date parameter cannot be converted to
    a pandas timestamp

\end{description}\end{quote}

\end{fulllineitems}

\index{process\_new\_df() (in module dalio.util)@\spxentry{process\_new\_df()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.process_new_df}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{process\_new\_df}}}{\emph{df1}, \emph{df2}, \emph{cols}, \emph{new\_cols}}{}
Process new dataframe given columns and new column names
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df1}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} first dataframe.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df2}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dataframe to join or get columns from

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}) \textendash{} iterable of columns being targetted.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{new\_cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}) \textendash{} iterable of new column names.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{translate\_df() (in module dalio.util)@\spxentry{translate\_df()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.translate_df}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{translate\_df}}}{\emph{translator}, \emph{df}, \emph{inplace=False}}{}
Translate dataframe column and index names in accordance to translator
dictionary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{translator}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} dictionary of \{original: translated\} key value
pairs.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dataframe to have rows and columns translated.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inplace}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether to perform operation inplace or return a
translated copy. Optional. Defaults to False.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_efficient\_frontier() (in module dalio.util)@\spxentry{plot\_efficient\_frontier()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.plot_efficient_frontier}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{plot\_efficient\_frontier}}}{\emph{cla}, \emph{points=100}, \emph{show\_assets=True}, \emph{ax=None}, \emph{**kwargs}}{}
Plot the efficient frontier based on a CLA object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{points}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of points to plot. Optional. Defaults to 100

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{show\_assets}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether we should plot the asset risks/returns
also. Optional. Defaults to True.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{matplolib.axis}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Axis to plot on. Optional. New axis will
be created if none is specified.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} optional parameters for main graph.

\end{itemize}

\item[{Returns}] \leavevmode
matplotlib axis

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_covariance() (in module dalio.util)@\spxentry{plot\_covariance()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.plot_covariance}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{plot\_covariance}}}{\emph{cov\_matrix}, \emph{plot\_correlation=False}, \emph{show\_tickers=True}, \emph{ax=None}}{}
Generate a basic plot of the covariance (or correlation) matrix,
given a covariance matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cov\_matrix}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} covariance matrix

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plot\_correlation}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether to plot the correlation matrix
instead, defaults to False. Optional.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{show\_tickers}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether to use tickers as labels (not
recommended for large portfolios). Optional. Defaults to True.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{matplolib.axis}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Axis to plot on. Optional. New axis will
be created if none is specified.

\end{itemize}

\item[{Returns}] \leavevmode
matplotlib axis

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_weights() (in module dalio.util)@\spxentry{plot\_weights()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.plot_weights}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{plot\_weights}}}{\emph{weights}, \emph{ax=None}, \emph{**kwargs}}{}
Plot the portfolio weights as a horizontal bar chart
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weights}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} the weights outputted by any PyPortfolioOpt
optimiser.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{matplolib.axis}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Axis to plot on. Optional. New axis will
be created if none is specified.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} optional parameters for main graph.

\end{itemize}

\item[{Returns}] \leavevmode
matplotlib axis

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{d}
\item\relax\sphinxstyleindexentry{dalio.application.application}\sphinxstyleindexpageref{dalio.application:\detokenize{module-dalio.application.application}}
\item\relax\sphinxstyleindexentry{dalio.application.graphers}\sphinxstyleindexpageref{dalio.application:\detokenize{module-dalio.application.graphers}}
\item\relax\sphinxstyleindexentry{dalio.application.printers}\sphinxstyleindexpageref{dalio.application:\detokenize{module-dalio.application.printers}}
\item\relax\sphinxstyleindexentry{dalio.base}\sphinxstyleindexpageref{dalio.base:\detokenize{module-dalio.base}}
\item\relax\sphinxstyleindexentry{dalio.base.builder}\sphinxstyleindexpageref{dalio.base:\detokenize{module-dalio.base.builder}}
\item\relax\sphinxstyleindexentry{dalio.base.constants}\sphinxstyleindexpageref{dalio.base:\detokenize{module-dalio.base.constants}}
\item\relax\sphinxstyleindexentry{dalio.base.datadef}\sphinxstyleindexpageref{dalio.base:\detokenize{module-dalio.base.datadef}}
\item\relax\sphinxstyleindexentry{dalio.base.node}\sphinxstyleindexpageref{dalio.base:\detokenize{module-dalio.base.node}}
\item\relax\sphinxstyleindexentry{dalio.base.transformer}\sphinxstyleindexpageref{dalio.base:\detokenize{module-dalio.base.transformer}}
\item\relax\sphinxstyleindexentry{dalio.external.external}\sphinxstyleindexpageref{dalio.external:\detokenize{module-dalio.external.external}}
\item\relax\sphinxstyleindexentry{dalio.external.file}\sphinxstyleindexpageref{dalio.external:\detokenize{module-dalio.external.file}}
\item\relax\sphinxstyleindexentry{dalio.external.image}\sphinxstyleindexpageref{dalio.external:\detokenize{module-dalio.external.image}}
\item\relax\sphinxstyleindexentry{dalio.external.web}\sphinxstyleindexpageref{dalio.external:\detokenize{module-dalio.external.web}}
\item\relax\sphinxstyleindexentry{dalio.model.financial}\sphinxstyleindexpageref{dalio.model:\detokenize{module-dalio.model.financial}}
\item\relax\sphinxstyleindexentry{dalio.model.model}\sphinxstyleindexpageref{dalio.model:\detokenize{module-dalio.model.model}}
\item\relax\sphinxstyleindexentry{dalio.ops}\sphinxstyleindexpageref{dalio.ops:\detokenize{module-dalio.ops}}
\item\relax\sphinxstyleindexentry{dalio.pipe.builders}\sphinxstyleindexpageref{dalio.pipe:\detokenize{module-dalio.pipe.builders}}
\item\relax\sphinxstyleindexentry{dalio.pipe.col\_generation}\sphinxstyleindexpageref{dalio.pipe:\detokenize{module-dalio.pipe.col_generation}}
\item\relax\sphinxstyleindexentry{dalio.pipe.custom}\sphinxstyleindexpageref{dalio.pipe:\detokenize{module-dalio.pipe.custom}}
\item\relax\sphinxstyleindexentry{dalio.pipe.forecast}\sphinxstyleindexpageref{dalio.pipe:\detokenize{module-dalio.pipe.forecast}}
\item\relax\sphinxstyleindexentry{dalio.pipe.pipe}\sphinxstyleindexpageref{dalio.pipe:\detokenize{module-dalio.pipe.pipe}}
\item\relax\sphinxstyleindexentry{dalio.pipe.selection}\sphinxstyleindexpageref{dalio.pipe:\detokenize{module-dalio.pipe.selection}}
\item\relax\sphinxstyleindexentry{dalio.translator.file}\sphinxstyleindexpageref{dalio.translator:\detokenize{module-dalio.translator.file}}
\item\relax\sphinxstyleindexentry{dalio.translator.pdr}\sphinxstyleindexpageref{dalio.translator:\detokenize{module-dalio.translator.pdr}}
\item\relax\sphinxstyleindexentry{dalio.translator.quandl}\sphinxstyleindexpageref{dalio.translator:\detokenize{module-dalio.translator.quandl}}
\item\relax\sphinxstyleindexentry{dalio.translator.translator}\sphinxstyleindexpageref{dalio.translator:\detokenize{module-dalio.translator.translator}}
\item\relax\sphinxstyleindexentry{dalio.util}\sphinxstyleindexpageref{dalio.util:\detokenize{module-dalio.util}}
\item\relax\sphinxstyleindexentry{dalio.util.plotting\_utils}\sphinxstyleindexpageref{dalio.util:\detokenize{module-dalio.util.plotting_utils}}
\item\relax\sphinxstyleindexentry{dalio.util.processing\_utils}\sphinxstyleindexpageref{dalio.util:\detokenize{module-dalio.util.processing_utils}}
\item\relax\sphinxstyleindexentry{dalio.util.translation\_utils}\sphinxstyleindexpageref{dalio.util:\detokenize{module-dalio.util.translation_utils}}
\item\relax\sphinxstyleindexentry{dalio.validator}\sphinxstyleindexpageref{dalio.validator:\detokenize{module-dalio.validator}}
\item\relax\sphinxstyleindexentry{dalio.validator.array\_val}\sphinxstyleindexpageref{dalio.validator:\detokenize{module-dalio.validator.array_val}}
\item\relax\sphinxstyleindexentry{dalio.validator.base\_val}\sphinxstyleindexpageref{dalio.validator:\detokenize{module-dalio.validator.base_val}}
\item\relax\sphinxstyleindexentry{dalio.validator.pandas\_val}\sphinxstyleindexpageref{dalio.validator:\detokenize{module-dalio.validator.pandas_val}}
\item\relax\sphinxstyleindexentry{dalio.validator.presets}\sphinxstyleindexpageref{dalio.validator:\detokenize{module-dalio.validator.presets}}
\item\relax\sphinxstyleindexentry{dalio.validator.validator}\sphinxstyleindexpageref{dalio.validator:\detokenize{module-dalio.validator.validator}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}